<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-02-14">

<title>Dynamic discrete choice models, reinforcement learning and Harold, part 2 – Econometrics and Free Software</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-3fe3df12cb322cd60d4f50ab5ce79ec8.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-87d0f794bf36b87d4b3f18c9d77400ff.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.bunny.net/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');
</style>
</head><body><table width="100%" height="100%" style="text-align: center;">
    <tbody><tr><td>
      <a href="index.qmd">Website</a> - 
      <a href="https://www.youtube.com/@brodriguesco">Youtube</a> - 
      <a href="about.qmd">About</a> - 
      <a href="talks.qmd">Talks</a> -
      <a href="books.qmd">Books</a> - 
      <a href="packages.qmd">Packages</a> -
      <a href="index.xml">RSS</a>
    </td>
</tr></tbody></table>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">




<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Dynamic discrete choice models, reinforcement learning and Harold, part 2</h1>
  <div class="quarto-categories">
    <div class="quarto-category">R</div>
    <div class="quarto-category">econometrics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 14, 2020</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div style="text-align:center;">
<p>
<a href="https://youtu.be/ZwRuneeLsCQ?t=229"> <img src="../assets/img/bus.jpg" title="very nice" width="80%" height="auto"></a>
</p>
</div>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<p>
<em>In this blog post, I present a paper that has really interested me for a long time. This is part2, where I will briefly present the model of the paper, and try to play around with the data. If you haven’t, I suggest you read <a href="https://www.brodrigues.co/blog/2020-01-26-harold/">part 1</a> where I provide more context.</em>
</p>
<section id="rusts-model" class="level2">
<h2 class="anchored" data-anchor-id="rusts-model">
Rust’s model
</h2>
<p>
Welcome to part 2 of this series, which might or might not have a part 3. I have been quite busy with this paper and especially with reinforcement learning these past couple of weeks, but in the meantime, other <a href="https://www.youtube.com/channel/UCTZXht1RTL2Duc3eU8MYGzQ">things</a> have taken some of my time, so who knows if I’ll keep discussing this paper.
</p>
<p>
Before going into the data, let me describe the model very broadly. The problem is as follows: each month, Harold Zurcher must decide whether to simply perform some basic maintenance on the buses he’s responsible for, or he can decide to completely replace the engine. Let his utility function be as follows:
</p>
<p>
<span class="math display">[ u(x_t, i_t, _1) = {
<span class="math display">\[\begin{array}{lcl}
-c(x_t, \theta_1) &amp;amp; \text{if} &amp;amp; i_t = 0, \\
-[\overline{P} - \underline{P} + c(0, \theta_1)] &amp;amp; \text{if} &amp;amp; i_t = 1,\\
\end{array}\]</span>
. ]</span>
</p>
<p>
where <span class="math inline">(x_t)</span> is the state variable, the reading of the odometer at month <span class="math inline">(t)</span>, <span class="math inline">(i_t)</span> is Harold Zurcher’s decision at time <span class="math inline">(t)</span>. <span class="math inline">(i_t = 0)</span> is the decision to keep the engine, <span class="math inline">(i_t = 1)</span> is the decision to replace. Each time the engine is replaced, the state variable <span class="math inline">(x_t)</span> regenerates to 0. That is why John Rust, the paper’s author, calls the problem under study a regenerative optimal stopping model. If <span class="math inline">(i_t = 0)</span> (keep the engine) is chosen, then the cost of normal maintenance is <span class="math inline">(c(x_t, _1))</span>, if <span class="math inline">(i_t = 1)</span> (change the engine) then the cost is <span class="math inline">()</span>, which is the price of the new engine. However, it is still possible to sell the old engine for scrap value, <span class="math inline">()</span>. The replacement cost is equal to <span class="math inline">(c(0, _1))</span>. <span class="math inline">(_1)</span> is a vector of parameters of the cost function to estimate. Because Harold Zurcher is forward looking, and does not want to simply maximize the current month’s utility, he seeks to maximize his intertemporal utility function. The optimal policy would be the solution to the following equation:
</p>
<p>
<span class="math display">[ V_{} = E{ _{j = t}<sup></sup>{j-t}u(x_j, f_j, _1) | x_t} ]</span>
</p>
<p>
This is a so-called value function, which is the total reward at the solution of the problem.
</p>
<p>
The state variable evolves according to a stochastic process given by the following transition probability:
</p>
<p>
<span class="math display">[ p(x_{t+1} | x_t, i_t, _2) = {
<span class="math display">\[\begin{array}{lllll}
\theta_2 \exp\{\theta_2(x_{t+1} - x_t)\} &amp;amp; \text{if} &amp;amp; i_t = 0 &amp;amp; \text{and} &amp;amp; x_{t+1} \geq x_t \\
\theta_2 \exp\{\theta_2(x_{t+1})\} &amp;amp; \text{if} &amp;amp; i_t = 0 &amp;amp; \text{and} &amp;amp; x_{t+1} \geq 0 \\
0 &amp;amp; \text{otherwise}\\
\end{array}\]</span>
. ]</span>
</p>
<p>
<span class="math inline">(_2)</span> is the parameter of the exponential distribution, another parameter to estimate. I’ll stop with one more equation, the Bellman equation:
</p>
<p>
<span class="math display">[ V_(x_t) = _{i_t C(x_t)} [u(x_t, i_t, <em>1) + EV</em>(x_t, i_t)] ]</span>
</p>
<p>
where <span class="math inline">(C(x_t) = {0, 1})</span> is the action set. The value function is the unique solution to this Bellman equation.
</p>
<p>
As you can see, this is quite complex (and I have not detailed everything!) but the advantage of models is that one can estimate its structural parameters and put a dollar value on the expected replacement cost, <span class="math inline">( - )</span> in addition to validating the very first hypothesis of the paper; does Harold Zurcher behave optimally?
</p>
<p>
In what follows, I’ll use the <code>{ReinforcementLearning}</code> package to try to find the optimal policy rule. The optimal policy rule tells us what is the best action at each period. Reinforcement learning is an approach that is widely used in machine learning to solve problems very similar to the one that I described above. However, as we shall see, it will fail here, and there’s a very good reason for that. First, let’s load the data that was prepared last time:
</p>
<pre class="r"><code>all_bus_data &lt;- read_csv("https://raw.githubusercontent.com/b-rodrigues/rust/ee15fb87fc4ba5db28d055c97a898b328725f53c/datasets/processed_data/all_buses.csv")</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   bus_id = col_double(),
##   date = col_date(format = ""),
##   odometer_reading = col_double(),
##   replacement = col_double(),
##   bus_family = col_character()
## )</code></pre>
<pre class="r"><code>head(all_bus_data)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   bus_id date       odometer_reading replacement bus_family
##    &lt;dbl&gt; &lt;date&gt;                &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;     
## 1   4239 1974-12-01           140953           0 a452372   
## 2   4239 1975-01-01           142960           0 a452372   
## 3   4239 1975-02-01           145380           0 a452372   
## 4   4239 1975-03-01           148140           0 a452372   
## 5   4239 1975-04-01           150921           0 a452372   
## 6   4239 1975-05-01           153839           0 a452372</code></pre>
<p>
In the paper, the author groups the 4 following bus families, so I’ll be doing the same:
</p>
<pre class="r"><code>family_group &lt;- c("g870", "rt50", "t8h203", "a530875")

group1_4 &lt;- all_bus_data %&gt;%
  filter(bus_family %in% family_group)

ggplot(group1_4) + 
  geom_line(aes(y = odometer_reading, x = date, group = bus_id, col = bus_family)) + 
  geom_point(aes(y = ifelse(odometer_reading*replacement == 0, NA, odometer_reading*replacement), 
                 x = date), col = "red") +
  labs(title = paste0("Odometer readings for bus families ", paste0(family_group, collapse = ", ")),
       caption = "The red dots are replacement events.") + 
  theme(plot.caption = element_text(colour = "white")) +
  brotools::theme_blog()</code></pre>
<pre><code>## Warning: Removed 8200 rows containing missing values (geom_point).</code></pre>
<p>
<img src="../assets/img/harold_part2-3-1.png" width="80%" height="auto">
</p>
<p>
There are 104 buses in this subset of data. Let’s discretize the odometer reading using the <code>ntile()</code> function. Discretizing the state variable will make computation faster:
</p>
<pre class="r"><code>group1_4 &lt;- group1_4 %&gt;%  
  mutate(state_at_replacement = ifelse(replacement == 1, odometer_reading, NA)) %&gt;%
  group_by(bus_id) %&gt;%
  fill(state_at_replacement, .direction = "down") %&gt;%
  ungroup() %&gt;%  
  mutate(state_at_replacement = odometer_reading - state_at_replacement) %&gt;%
  mutate(state_at_replacement = ifelse(is.na(state_at_replacement), odometer_reading, state_at_replacement)) %&gt;%  
  mutate(state = ntile(state_at_replacement, 50))</code></pre>
<p>
Let me also save the bus ids in a vector, I’ll need it later:
</p>
<pre class="r"><code>buses &lt;- unique(group1_4$bus_id)</code></pre>
<p>
To use the dataset with the <code>{ReinforcementLearning}</code> package, it must first be prepared:
</p>
<pre class="r"><code>group1_4 &lt;- group1_4 %&gt;%
  group_by(bus_id) %&gt;%  
  mutate(next_state = lead(state, 1)) %&gt;%
  mutate(replacement = lead(replacement, 1)) %&gt;%  
  mutate(action = replacement) %&gt;% 
  select(state, action, reward = replacement, next_state) %&gt;%
  mutate(reward = (-1)*reward) %&gt;%
  mutate(action = ifelse(is.na(action), 0, action),
         reward = ifelse(is.na(reward), 0, reward)) %&gt;%  
  mutate(next_state = ifelse(is.na(next_state), state + 1, next_state)) %&gt;% 
  mutate(state = as.character(state),
         next_state = as.character(next_state),
         action = as.character(action)) </code></pre>
<pre><code>## Adding missing grouping variables: `bus_id`</code></pre>
<p>
Let’s see how the data looks:
</p>
<pre class="r"><code>head(group1_4)</code></pre>
<pre><code>## # A tibble: 6 x 5
## # Groups:   bus_id [1]
##   bus_id state action reward next_state
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;     
## 1   5297 2     0           0 3         
## 2   5297 3     0           0 4         
## 3   5297 4     0           0 5         
## 4   5297 5     0           0 6         
## 5   5297 6     0           0 8         
## 6   5297 8     0           0 9</code></pre>
<p>
So when action 0 (do nothing) is chosen, the value of the state is increased by one. If action 1 (replace) is chosen:
</p>
<pre class="r"><code>group1_4 %&gt;%
  filter(action == "1") %&gt;%
  head</code></pre>
<pre><code>## # A tibble: 6 x 5
## # Groups:   bus_id [6]
##   bus_id state action reward next_state
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;     
## 1   5297 34    1          -1 1         
## 2   5299 42    1          -1 1         
## 3   5300 43    1          -1 1         
## 4   5301 36    1          -1 1         
## 5   5302 30    1          -1 1         
## 6   5303 49    1          -1 1</code></pre>
<p>
The state goes back to 1, and the reward is -1.
</p>
<p>
Now, let’s split the dataset into two: a training dataset and a testing dataset:
</p>
<pre class="r"><code>set.seed(1234)
train_buses &lt;- sample(buses, size = round(length(buses)*.8))

test_buses &lt;- setdiff(buses, train_buses)</code></pre>
<p>
There will be 83 in the training data and 21 in the testing data:
</p>
<pre class="r"><code>train_data &lt;- group1_4 %&gt;%
  filter(bus_id %in% train_buses)

test_data &lt;- group1_4 %&gt;%
  filter(bus_id %in% test_buses)</code></pre>
<p>
We’re finally ready to use the <code>{ReinforcementLearning}</code> package.
</p>
<pre class="r"><code>library(ReinforcementLearning)
model &lt;- ReinforcementLearning(train_data,
                                         s = "state",
                                         a = "action",
                                         r = "reward",
                                         s_new = "next_state")</code></pre>
<p>
Now what’s the result?
</p>
<pre class="r"><code>model</code></pre>
<pre><code>## State-Action function Q
##     0        1
## X30 0 -0.19000
## X31 0  0.00000
## X1  0  0.00000
## X32 0  0.00000
## X2  0  0.00000
## X33 0 -0.10000
## X3  0  0.00000
## X34 0 -0.19000
## X4  0  0.00000
## X35 0  0.00000
## X5  0  0.00000
## X36 0 -0.19000
## X6  0  0.00000
## X37 0 -0.10000
## X7  0  0.00000
## X38 0  0.00000
## X8  0  0.00000
## X39 0 -0.34390
## X9  0  0.00000
## X10 0  0.00000
## X40 0 -0.10000
## X11 0  0.00000
## X41 0 -0.10000
## X12 0  0.00000
## X42 0 -0.34390
## X13 0  0.00000
## X43 0 -0.40951
## X14 0  0.00000
## X44 0 -0.19000
## X45 0 -0.34390
## X15 0  0.00000
## X46 0 -0.27100
## X16 0  0.00000
## X47 0 -0.19000
## X17 0  0.00000
## X48 0 -0.40951
## X18 0  0.00000
## X49 0 -0.34390
## X19 0  0.00000
## X50 0 -0.34390
## X20 0  0.00000
## X21 0  0.00000
## X22 0  0.00000
## X23 0  0.00000
## X24 0  0.00000
## X25 0  0.00000
## X26 0  0.00000
## X27 0  0.00000
## X28 0  0.00000
## X29 0 -0.10000
## 
## Policy
## X30 X31  X1 X32  X2 X33  X3 X34  X4 X35  X5 X36  X6 X37  X7 X38  X8 X39  X9 X10 
## "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" 
## X40 X11 X41 X12 X42 X13 X43 X14 X44 X45 X15 X46 X16 X47 X17 X48 X18 X49 X19 X50 
## "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" 
## X20 X21 X22 X23 X24 X25 X26 X27 X28 X29 
## "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" 
## 
## Reward (last iteration)
## [1] -48</code></pre>
<p>
We see that the optimal policy is always to do nothing! This is actually “normal” here, as we are using historical data; and in this data, there is no information on the likelihood of severe engine failure if one does not replace it completely at some point! So the agent does not see the point in replacing the engine; it costs money and does not seem to bring in any benefit!
</p>
<p>
Another way of using the <code>{ReinforcementLearning}</code> package is to write a function that simulates the environment. One could write such a function, and add in it a probability of severe failure with a very big cost. This probability would increase as the state (number of miles driven) increases as well. With such a function, there would be simulations where the cost of doing nothing would be very high, and as such, hopefully, the agent would learn that replacing the engine once might be a better course of action than doing nothing.
</p>
<p>
This might be the subject of part 3 of this series!
</p>


</section>

</main> <!-- /main -->
<hr style="border: 1px solid #ccc; margin: 20px 0;">
<footer>
If you find the content in this blog useful, you might want to follow
me on <a href="https://fosstodon.org/@brodriguesco">Mastodon</a> or <a href="https://www.twitter.com/brodriguesco">twitter</a> for blog post updates or
<a href="https://www.buymeacoffee.com/brodriguesco">buy me an espresso</a> or <a href="https://www.paypal.me/brodriguesco">paypal.me</a>, or buy my <a href="../books.html">ebooks</a>.
You can also watch my videos on <a href="https://www.youtube.com/c/BrunoRodrigues1988/">youtube</a>.
So much content for you to consoom!
<p></p>
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style>
<p>
<link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/brodriguesco"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me an Espresso"><span style="margin-left:5px">Buy me an Espresso</span></a>
</p>
  <div class="row">
    <div class="col-lg-12">
        <p>© <span id="year"></span>, content by Bruno Rodrigues, unless otherwise stated, every content of this blog is licensed under the <a href="http://www.wtfpl.net/txt/copying/" rel="nofollow">WTFPL</a>.</p>
        <p>Built with <a href="https://quarto.org/">Quarto</a> and <a href="https://nixos.org/explore/">Nix</a>, hosted on <a href="https://pages.github.com/">GitHub Pages</a>.</p>
      <p><a href="../index.html">Back to main page.</a></p>
    </div>
  </div>
</footer>
<script>
 document.getElementById('year').textContent = new Date().getFullYear();
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/b-rodrigues\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>