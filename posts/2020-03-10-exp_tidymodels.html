<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-03-10">

<title>Explainbility of {tidymodels} models with {iml} – Econometrics and Free Software</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-3fe3df12cb322cd60d4f50ab5ce79ec8.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-87d0f794bf36b87d4b3f18c9d77400ff.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.bunny.net/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');
</style>
</head><body><table width="100%" height="100%" style="text-align: center;">
    <tbody><tr><td>
      <a href="https://b-rodrigues.github.io/blog/">Website</a> - 
      <a href="https://www.youtube.com/@brodriguesco">Youtube</a> - 
      <a href="https://b-rodrigues.github.io/blog/about.html">About</a> - 
      <a href="https://b-rodrigues.github.io/blog/talks.html">Talks</a> -
      <a href="https://b-rodrigues.github.io/blog/books.html">Books</a> - 
      <a href="https://b-rodrigues.github.io/blog/packages.html">Packages</a> -
      <a href="https://b-rodrigues.github.io/blog/index.xml">RSS</a>
    </td>
</tr></tbody></table>


<link rel="stylesheet" href="../styles.css">




<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Explainbility of {tidymodels} models with {iml}</h1>
  <div class="quarto-categories">
    <div class="quarto-category">R</div>
    <div class="quarto-category">data-science</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 10, 2020</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div style="text-align:center;">
<p>
<a href="https://en.wikipedia.org/wiki/Rhetoric"> <img src="../assets/img/exp_tidymodels.jpg" title="'{rethoric}' would be a sick package name for explainability" width="80%" height="auto"></a>
</p>
</div>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<p>
In my previous <a href="../posts/2020-03-08-tidymodels.html">blog post</a>, I have shown how you could use <code>{tidymodels}</code> to train several machine learning models. Now, let’s take a look at getting some explanations out of them, using the <code>{iml}</code> package. Originally I did not intend to create a separate blog post, but I have encountered… an issue, or bug, when using both <code>{iml}</code> and <code>{tidymodels}</code> and I felt that it was important that I write about it. Maybe it’s just me that’s missing something, and you, kind reader, might be able to give me an answer. But let’s first reload the models from last time (the same packages as on the previous blog post are loaded):
</p>
<pre class="r"><code>trained_models_list</code></pre>
<pre><code>## [[1]]
## #  10-fold cross-validation 
## # A tibble: 10 x 4
##    splits               id     .metrics          .notes          
##  * &lt;list&gt;               &lt;chr&gt;  &lt;list&gt;            &lt;list&gt;          
##  1 &lt;split [23.6K/2.6K]&gt; Fold01 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  2 &lt;split [23.6K/2.6K]&gt; Fold02 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  3 &lt;split [23.6K/2.6K]&gt; Fold03 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  4 &lt;split [23.6K/2.6K]&gt; Fold04 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  5 &lt;split [23.6K/2.6K]&gt; Fold05 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  6 &lt;split [23.6K/2.6K]&gt; Fold06 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  7 &lt;split [23.6K/2.6K]&gt; Fold07 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  8 &lt;split [23.6K/2.6K]&gt; Fold08 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  9 &lt;split [23.6K/2.6K]&gt; Fold09 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 10 &lt;split [23.6K/2.6K]&gt; Fold10 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 
## [[2]]
## #  10-fold cross-validation 
## # A tibble: 10 x 4
##    splits               id     .metrics          .notes          
##  * &lt;list&gt;               &lt;chr&gt;  &lt;list&gt;            &lt;list&gt;          
##  1 &lt;split [23.6K/2.6K]&gt; Fold01 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  2 &lt;split [23.6K/2.6K]&gt; Fold02 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  3 &lt;split [23.6K/2.6K]&gt; Fold03 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  4 &lt;split [23.6K/2.6K]&gt; Fold04 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  5 &lt;split [23.6K/2.6K]&gt; Fold05 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  6 &lt;split [23.6K/2.6K]&gt; Fold06 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  7 &lt;split [23.6K/2.6K]&gt; Fold07 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  8 &lt;split [23.6K/2.6K]&gt; Fold08 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  9 &lt;split [23.6K/2.6K]&gt; Fold09 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 10 &lt;split [23.6K/2.6K]&gt; Fold10 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 
## [[3]]
## #  10-fold cross-validation 
## # A tibble: 10 x 4
##    splits               id     .metrics          .notes          
##  * &lt;list&gt;               &lt;chr&gt;  &lt;list&gt;            &lt;list&gt;          
##  1 &lt;split [23.6K/2.6K]&gt; Fold01 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  2 &lt;split [23.6K/2.6K]&gt; Fold02 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  3 &lt;split [23.6K/2.6K]&gt; Fold03 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  4 &lt;split [23.6K/2.6K]&gt; Fold04 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  5 &lt;split [23.6K/2.6K]&gt; Fold05 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  6 &lt;split [23.6K/2.6K]&gt; Fold06 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  7 &lt;split [23.6K/2.6K]&gt; Fold07 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  8 &lt;split [23.6K/2.6K]&gt; Fold08 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  9 &lt;split [23.6K/2.6K]&gt; Fold09 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 10 &lt;split [23.6K/2.6K]&gt; Fold10 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 
## [[4]]
## #  10-fold cross-validation 
## # A tibble: 10 x 4
##    splits               id     .metrics          .notes          
##  * &lt;list&gt;               &lt;chr&gt;  &lt;list&gt;            &lt;list&gt;          
##  1 &lt;split [23.6K/2.6K]&gt; Fold01 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  2 &lt;split [23.6K/2.6K]&gt; Fold02 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  3 &lt;split [23.6K/2.6K]&gt; Fold03 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  4 &lt;split [23.6K/2.6K]&gt; Fold04 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  5 &lt;split [23.6K/2.6K]&gt; Fold05 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  6 &lt;split [23.6K/2.6K]&gt; Fold06 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  7 &lt;split [23.6K/2.6K]&gt; Fold07 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  8 &lt;split [23.6K/2.6K]&gt; Fold08 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
##  9 &lt;split [23.6K/2.6K]&gt; Fold09 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
## 10 &lt;split [23.6K/2.6K]&gt; Fold10 &lt;tibble [20 × 7]&gt; &lt;tibble [1 × 1]&gt;
## 
## [[5]]
## #  10-fold cross-validation 
## # A tibble: 10 x 4
##    splits               id     .metrics          .notes          
##  * &lt;list&gt;               &lt;chr&gt;  &lt;list&gt;            &lt;list&gt;          
##  1 &lt;split [23.6K/2.6K]&gt; Fold01 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  2 &lt;split [23.6K/2.6K]&gt; Fold02 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  3 &lt;split [23.6K/2.6K]&gt; Fold03 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  4 &lt;split [23.6K/2.6K]&gt; Fold04 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  5 &lt;split [23.6K/2.6K]&gt; Fold05 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  6 &lt;split [23.6K/2.6K]&gt; Fold06 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  7 &lt;split [23.6K/2.6K]&gt; Fold07 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  8 &lt;split [23.6K/2.6K]&gt; Fold08 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
##  9 &lt;split [23.6K/2.6K]&gt; Fold09 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;
## 10 &lt;split [23.6K/2.6K]&gt; Fold10 &lt;tibble [20 × 5]&gt; &lt;tibble [1 × 1]&gt;</code></pre>
<p>
Let’s see which of the models performed best (in cross-validation):
</p>
<pre class="r"><code>trained_models_list %&gt;%
  map(show_best, metric = "accuracy", n = 1)</code></pre>
<pre><code>## [[1]]
## # A tibble: 1 x 7
##    penalty mixture .metric  .estimator  mean     n std_err
##      &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
## 1 6.57e-10  0.0655 accuracy binary     0.916    10 0.00179
## 
## [[2]]
## # A tibble: 1 x 7
##    mtry trees .metric  .estimator  mean     n std_err
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
## 1    13  1991 accuracy binary     0.929    10 0.00172
## 
## [[3]]
## # A tibble: 1 x 7
##   num_terms prune_method .metric  .estimator  mean     n std_err
##       &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
## 1         5 backward     accuracy binary     0.904    10 0.00186
## 
## [[4]]
## # A tibble: 1 x 9
##    mtry trees tree_depth learn_rate .metric  .estimator  mean     n std_err
##   &lt;int&gt; &lt;int&gt;      &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
## 1    12  1245         12     0.0770 accuracy binary     0.929    10 0.00175
## 
## [[5]]
## # A tibble: 1 x 7
##   hidden_units    penalty .metric  .estimator  mean     n std_err
##          &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
## 1           10 0.00000307 accuracy binary     0.917    10 0.00209</code></pre>
<p>
Seems like the second model, the random forest performed the best (highest mean accuracy with lowest standard error). So let’s retrain the model on the whole training set and see how it fares on the testing set:
</p>
<pre class="r"><code>rf_specs &lt;- trained_models_list[[2]]</code></pre>
<p>
Let’s save the best model specification in a variable:
</p>
<pre class="r"><code>best_rf_spec &lt;- show_best(rf_specs, "accuracy", 1)</code></pre>
<p>
Let’s now retrain this model, using a workflow:
</p>
<pre class="r"><code>best_rf_model &lt;- rand_forest(mode = "classification", mtry = best_rf_spec$mtry,
                           trees = best_rf_spec$trees) %&gt;%
  set_engine("ranger")

preprocess &lt;- recipe(job_search ~ ., data = pra) %&gt;%
  step_dummy(all_predictors())

pra_wflow_best &lt;- workflow() %&gt;%
  add_recipe(preprocess) %&gt;%
  add_model(best_rf_model)

best_model_fitted &lt;- fit(pra_wflow_best, data = pra_train)</code></pre>
<pre><code>## Warning: The following variables are not factor vectors and will be ignored:
## `hours`</code></pre>
<p>
and let’s take a look at the confusion matrix:
</p>
<pre class="r"><code>predictions &lt;- predict(best_model_fitted, new_data = pra_test) %&gt;%
  bind_cols(pra_test)

predictions %&gt;%
  mutate(job_search = as.factor(job_search)) %&gt;%  
  accuracy(job_search, .pred_class)</code></pre>
<pre><code>## # A tibble: 1 x 3
##   .metric  .estimator .estimate
##   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;
## 1 accuracy binary         0.924</code></pre>
<pre class="r"><code>predictions %&gt;%
  mutate(job_search = as.factor(job_search)) %&gt;%  
  conf_mat(job_search, .pred_class) </code></pre>
<pre><code>##           Truth
## Prediction    N    S
##          N 2539  156
##          S   64  149</code></pre>
<p>
We see that predicting class <code>S</code> (“Si”, meaning, “yes” in Spanish) is tricky. One would probably need to use techniques such as <code>SMOTE</code> to deal with this (see this <a href="https://www.brodrigues.co/blog/2018-02-11-census-random_forest/">blog post</a> for more info). Anyways, this is not today’s topic.
</p>
<p>
Let’s say that we are satisfied with the model and want some explanations out of it. I have already blogged about it in the past, so if you want more details, you can read this <a href="https://www.brodrigues.co/blog/2018-02-11-census-random_forest/">blog post</a>.
</p>
<p>
Now, what is important, is that I have defined a complete workflow to deal with the data preprocessing and then the training of the model. So I’ll be using this workflow as well to get my explainability. What I mean with this is the following: to get explanations, we need a model, and a way to get predictions out of it. As I have shown before, my fitted workflow is able to give me predictions. So I should have every needed ingredient; <code>{iml}</code>, the package that I am using for explainability provides several functions that work all the same; you first define an object that takes as an input the fitted model, the design matrix, the target variable and the prediction function. Let’s start with defining the design matrix and the target variable:
</p>
<pre class="r"><code>library("iml")

features &lt;- pra_test %&gt;%
  select(-job_search)

target &lt;- pra_test %&gt;%
  mutate(job_search = as.factor(job_search)) %&gt;%  
  select(job_search)</code></pre>
<p>
Now, let’s define the predict function:
</p>
<pre class="r"><code>predict_wrapper &lt;- function(model, newdata){
  workflows:::predict.workflow(object = model, new_data = newdata)
}</code></pre>
<p>
Because a workflow is a bit special, I need to define this wrapper function that wraps the <code>workflows:::predict.workflow()</code> function. Normally, users should not have to deal with this function; as you can see, to access it I had to use the very special <code>:::</code> function. <code>:::</code> permits users to access <em>private</em> functions (not sure if this is the right term; what I mean is that private functions are used internally by the package and should not be available to users. AFAIK, this is how these functions are called in Python). I tried simply using the <code>predict()</code> function, which works interactively but I was getting issues with it when I was providing it to the constructor below:
</p>
<pre class="r"><code>predictor &lt;- Predictor$new(
                         model = best_model_fitted,
                         data = features, 
                         y = target,
                         predict.fun = predict_wrapper
                       )</code></pre>
<p>
This creates a <code>Predictor</code> object from which I am now able to get explanations. For example, for feature importance, I would write the following:
</p>
<pre class="r"><code>feature_importance &lt;- FeatureImp$new(predictor, loss = "ce")

plot(feature_importance)</code></pre>
<p>
<img src="../assets/img/exp_tidymodels-13-1.png" width="80%" height="auto">
</p>
<p>
And this is where I noticed that something was wrong; the variables we are looking at are categorical variables. So why am I not seeing the categories? Why is the most important variable the contract type, without the category of the contract type that is the most important? Remember that I created dummy variables using a recipe. So I was expecting something like <code>type_of_contract_type_1</code>, <code>type_of_contract_type_2</code>, etc… as variables.
</p>
<p>
This made me want to try to fit the model “the old way”, without using workflows. So for this I need to use the <code>prep()</code>, <code>juice()</code> and <code>bake()</code> functions, which are included in the <code>{recipes}</code> package. I won’t go into much detail, but the idea is that <code>prep()</code> is used to train the recipe, and compute whatever is needed to preprocess the data (such as means and standard deviations for normalization). For this, you should use the training data only. <code>juice()</code> returns the preprocessed training set, and <code>bake()</code> is then used to preprocessed a new data set, for instance the test set, using the same estimated parameters that were obtained with <code>prep()</code>.
</p>
<p>
Using workflows avoids having to do these steps manually, but what I am hoping is that doing this manually will solve my issue. So let’s try:
</p>
<pre class="r"><code># without workflows
trained_recipe &lt;- prep(preprocess, training = pra_train)</code></pre>
<pre><code>## Warning: The following variables are not factor vectors and will be ignored:
## `hours`</code></pre>
<pre class="r"><code>pra_train_prep &lt;- juice(trained_recipe)


best_model_fit &lt;- fit(best_rf_model, job_search ~ ., data = pra_train_prep)


pra_test_bake_features &lt;- bake(trained_recipe, pra_test) %&gt;%
  select(-job_search)


predict_wrapper2 &lt;- function(model, newdata){
  predict(object = model, new_data = newdata)
}

predictor2 &lt;- Predictor$new(
                          model = best_model_fit,
                          data = pra_test_bake_features, 
                          y = target,
                          predict.fun = predict_wrapper2
                        )

feature_importance2 &lt;- FeatureImp$new(predictor2, loss = "ce")

plot(feature_importance2)</code></pre>
<p>
<img src="../assets/img/exp_tidymodels-14-1.png" width="80%" height="auto">
</p>
<p>
Eureka! As you can see, the issue is now solved; we now have all the variables that were used for training the model, also in our explanations. I don’t know exactly what’s going on; is this a bug? Is it because the <code>{workflows}</code> package makes this process too streamlined that it somehow <em>rebuilds</em> the features and then returns the results? I have no idea. In any case, it would seem that for the time being, doing the training and explanations without the <code>{workflows}</code> package is the way to go if you require explanations as well.
</p>



</main> <!-- /main -->
<hr style="border: 1px solid #ccc; margin: 20px 0;">
<footer>
If you find the content in this blog useful, you might want to follow
me on <a href="https://fosstodon.org/@brodriguesco">Mastodon</a> or <a href="https://www.twitter.com/brodriguesco">twitter</a> for blog post updates or
<a href="https://www.buymeacoffee.com/brodriguesco">buy me an espresso</a> or <a href="https://www.paypal.me/brodriguesco">paypal.me</a>, or buy my <a href="../books.html">ebooks</a>.
You can also watch my videos on <a href="https://www.youtube.com/c/BrunoRodrigues1988/">youtube</a>.
So much content for you to consoom!
<p></p>
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style>
<p>
<link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/brodriguesco"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me an Espresso"><span style="margin-left:5px">Buy me an Espresso</span></a>
</p>
  <div class="row">
    <div class="col-lg-12">
        <p>© <span id="year"></span>, content by Bruno Rodrigues, unless otherwise stated, every content of this blog is licensed under the <a href="http://www.wtfpl.net/txt/copying/" rel="nofollow">WTFPL</a>.</p>
        <p>Built with <a href="https://quarto.org/">Quarto</a> and <a href="https://nixos.org/explore/">Nix</a>, hosted on <a href="https://pages.github.com/">GitHub Pages</a>.</p>
      <p><a href="../index.html">Back to main page.</a></p>
    </div>
  </div>
</footer>
<script>
 document.getElementById('year').textContent = new Date().getFullYear();
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/b-rodrigues\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>