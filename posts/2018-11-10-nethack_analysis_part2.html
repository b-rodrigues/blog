<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2018-11-10">

<title>Analyzing NetHack data, part 2: What players kill the most – Econometrics and Free Software</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../assets/img/favicon-32x32.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-3fe3df12cb322cd60d4f50ab5ce79ec8.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-05d373f05c5d69f703950177dd9c153b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.bunny.net/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');
</style>
</head><body><table width="100%" height="100%" style="text-align: center;">
    <tbody><tr><td>
      <a href="https://b-rodrigues.github.io/blog/">Website</a> - 
      <a href="https://www.youtube.com/@brodriguesco">Youtube</a> - 
      <a href="https://b-rodrigues.github.io/blog/about.html">About</a> - 
      <a href="https://b-rodrigues.github.io/blog/talks.html">Talks</a> -
      <a href="https://b-rodrigues.github.io/blog/books.html">Books</a> - 
      <a href="https://b-rodrigues.github.io/blog/packages.html">Packages</a> -
      <a href="https://b-rodrigues.github.io/blog/index.xml">RSS</a>
    </td>
</tr></tbody></table>


<link rel="stylesheet" href="../styles.css">




<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Analyzing NetHack data, part 2: What players kill the most</h1>
  <div class="quarto-categories">
    <div class="quarto-category">R</div>
    <div class="quarto-category">data-science</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 10, 2018</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div style="text-align:center;">
<p>
<a href="https://www.youtube.com/watch?v=VnW2g6qbbrA"> <img src="../assets/img/monsters.png" title="Wizard of Yendor battle music" width="80%" height="auto"></a>
</p>
</div>
<p>
Link to <a href="../posts/2018-11-01-nethack.html">webscraping the data</a>
</p>
<p>
Link to <a href="../posts/2018-11-03-nethack_analysis.html">Analysis, part 1</a>
</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">
Introduction
</h2>
<p>
This is the third blog post that deals with data from the game NetHack, and oh boy, did a lot of things happen since the last blog post! Here’s a short timeline of the events:
</p>
<ul>
<li>
I scraped data from <a href="https://alt.org/nethack/">alt.org/nethack</a> and made a package with the data available on Github (that package was too big for CRAN)
</li>
<li>
Then, I analyzed the data, focusing on what monsters kill the players the most, and also where players die the most
</li>
<li>
<span class="citation"><span class="citation" data-cites="GridSageGames">@GridSageGames</span></span>, developer of the roguelike Cogmind and moderator of the roguelike subreddit, posted the blog post on reddit
</li>
<li>
I noticed that actually, by scraping the data like I did, I only got a sample of 100 daily games
</li>
<li>
This point was also discussed on Reddit, and bhhak, an UnNetHack developer (UnNetHack is a fork of NetHack) suggested I used the xlogfiles instead
</li>
<li>
xlogfiles are log files generated by NetHack, and are also available on alt.org/nethack
</li>
<li>
I started scraping them, and getting a lot more data
</li>
<li>
I got contacted on twitter by <span class="citation"><span class="citation" data-cites="paxed">@paxed</span></span>, an admin of alt.org/nethack:
</li>
</ul>
{{% tweet “1059333642592366593” %}}
<ul>
<li>
He gave me access to ALL THE DATA on alt.org/nethack!
</li>
<li>
The admins of <a href="https://alt.org/nethack/">alt.org/nethack</a> will release all the data to the public!
</li>
</ul>
<p>
So, I will now continue with the blog post I wanted to do in the first place; focusing now on what roles players choose to play the most, and also which monsters they kill the most. BUT! Since all the data will be released to the public, my <code>{nethack}</code> package that contains data that I&nbsp;scraped is not that useful anymore. So I changed the nature of the package. Now the package contains some functions: a function to parse and prepare the xlogfiles from NetHack that you can download from <a href="https://alt.org/nethack/">alt.org/nethack</a> (or from any other public server), a function to download dumplogs such as this <a href="http://archive.is/7awsb">one</a>. These dumplogs contain a lot of info that I will extract in this blog post, using another function included in the <code>{nethack}</code> package. The package also contains a sample of 6000 runs from NetHack version 3.6.1.
</p>
<p>
You can install the package with the following command line:
</p>
<pre class="r"><code>devtools::install_github("b-rodrigues/nethack")</code></pre>
</section>
<section id="the-nethack-package" class="level2">
<h2 class="anchored" data-anchor-id="the-nethack-package">
The <code>{nethack}</code> package
</h2>
<p>
In <a href="../posts/2018-11-03-nethack_analysis.html">part 1</a> I showed what killed players the most. Here, I will focus on what monsters players kill the most. Let’s start by loading some packages:
</p>
<pre class="r"><code>library(tidyverse)
library(lubridate)
library(magrittr)
library(ggridges)
library(brotools)
library(rvest)
library(nethack)</code></pre>
<p>
Let’s first describe the data:
</p>
<pre class="r"><code>brotools::describe(nethack) %&gt;% 
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 23 x 17
##    variable type    nobs     mean       sd mode       min     max      q05
##    &lt;chr&gt;    &lt;chr&gt;  &lt;int&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
##  1 deathdn… Nume… 6.00e3  8.45e-1  1.30e+0 2       0.      7.00e0   0.    
##  2 deathlev Nume… 6.00e3  4.32e+0  3.69e+0 10     -5.00e0  4.50e1   1.00e0
##  3 deaths   Nume… 6.00e3  8.88e-1  3.54e-1 1       0.      5.00e0   0.    
##  4 endtime  Nume… 6.00e3  1.53e+9  4.72e+6 1534…   1.52e9  1.54e9   1.53e9
##  5 hp       Nume… 6.00e3  6.64e+0  4.96e+1 -1     -9.40e1  1.79e3  -8.00e0
##  6 maxhp    Nume… 6.00e3  3.82e+1  5.29e+1 57      2.00e0  1.80e3   1.10e1
##  7 maxlvl   Nume… 6.00e3  5.52e+0  6.36e+0 10      1.00e0  5.30e1   1.00e0
##  8 points   Nume… 6.00e3  4.69e+4  4.18e+5 10523   0.      9.92e6   1.40e1
##  9 realtime Nume… 6.00e3  4.42e+3  1.60e+4 4575    0.      3.23e5   6.90e1
## 10 startti… Nume… 6.00e3  1.53e+9  4.72e+6 1534…   1.52e9  1.54e9   1.53e9
## 11 turns    Nume… 6.00e3  3.60e+3  9.12e+3 6797    3.10e1  1.97e5   9.49e1
## 12 align    Char… 6.00e3 NA       NA       Cha    NA      NA       NA     
## 13 align0   Char… 6.00e3 NA       NA       Cha    NA      NA       NA     
## 14 death    Char… 6.00e3 NA       NA       kill…  NA      NA       NA     
## 15 gender   Char… 6.00e3 NA       NA       Fem    NA      NA       NA     
## 16 gender0  Char… 6.00e3 NA       NA       Fem    NA      NA       NA     
## 17 killed_… Char… 6.00e3 NA       NA       fain…  NA      NA       NA     
## 18 name     Char… 6.00e3 NA       NA       drud…  NA      NA       NA     
## 19 race     Char… 6.00e3 NA       NA       Elf    NA      NA       NA     
## 20 role     Char… 6.00e3 NA       NA       Wiz    NA      NA       NA     
## 21 dumplog  List  1.33e6 NA       NA       &lt;NA&gt;   NA      NA       NA     
## 22 birthda… Date  6.00e3 NA       NA       &lt;NA&gt;   NA      NA       NA     
## 23 deathda… Date  6.00e3 NA       NA       &lt;NA&gt;   NA      NA       NA     
## # ... with 8 more variables: q25 &lt;dbl&gt;, median &lt;dbl&gt;, q75 &lt;dbl&gt;,
## #   q95 &lt;dbl&gt;, n_missing &lt;int&gt;, n_unique &lt;int&gt;, starting_date &lt;date&gt;,
## #   ending_date &lt;date&gt;</code></pre>
<p>
All these columns are included in xlogfiles. The data was prepared using two functions, included in <code>{nethack}</code>:
</p>
<pre class="r"><code>xlog &lt;- read_delim("~/path/to/nethack361_xlog.csv", "\t", escape_double = FALSE, 
                   col_names = FALSE, trim_ws = TRUE)

xlog_df &lt;- clean_xlog(xlog)</code></pre>
<p>
<code>nethack361_xlog.csv</code> is the raw xlogfiles that you can get from NetHack public servers. <code>clean_xlog()</code> is a function that parses an xlogfile and returns a clean data frame. <code>xlog_df</code> will be a data frame that will look just as the one included in <code>{nethack}</code>. It is then possible to get the dumplog from each run included in <code>xlog_df</code> using <code>get_dumplog()</code>:
</p>
<pre class="r"><code>xlog_df &lt;- get_dumplog(xlog_df)</code></pre>
<p>
This function adds a column called <code>dumplog</code> with the dumplog of that run. I will now analyze the dumplog file, by focusing on monsters vanquished, genocided or extinct. In a future blogpost I will focus on other achievements.
</p>
</section>
<section id="roles-played-and-other-starting-stats" class="level2">
<h2 class="anchored" data-anchor-id="roles-played-and-other-starting-stats">
Roles played (and other starting stats)
</h2>
<p>
I will take a look at the races, roles, gender and alignment players start with the most. I will do pie charts to visualize these variable, so first, let’s start by writing a general function that allows me to do just that:
</p>
<pre class="r"><code>create_pie &lt;- function(dataset, variable, repel = FALSE){

  if(repel){
    geom_label &lt;- function(...){
      ggrepel::geom_label_repel(...)
    }
  }

  variable &lt;- enquo(variable)

  dataset %&gt;%
    count((!!variable)) %&gt;%
    mutate(total = sum(n),
           freq = n/total,
           labels = scales::percent(freq)) %&gt;% 
    arrange(desc(freq)) %&gt;%
    ggplot(aes(x = "", y = freq, fill = (!!variable))) + 
    geom_col() + 
    geom_label(aes(label = labels), position = position_stack(vjust = 0.25), show.legend = FALSE) + 
    coord_polar("y") + 
    theme_blog() + 
    scale_fill_blog() + 
    theme(legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank())
}</code></pre>
<p>
Now I can easily plot the share of races chosen:
</p>
<pre class="r"><code>create_pie(nethack, race)</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-9-1.png" width="80%" height="auto">
</div>
<p>
or the share of alignment:
</p>
<pre class="r"><code>create_pie(nethack, align0)</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-10-1.png" width="80%" height="auto">
</div>
<p>
Same for the share of gender:
</p>
<pre class="r"><code>create_pie(nethack, gender0)</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-11-1.png" width="80%" height="auto">
</div>
<p>
and finally for the share of roles:
</p>
<pre class="r"><code>create_pie(nethack, role, repel = TRUE) </code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-12-1.png" width="80%" height="auto">
</div>
<p>
<code>create_pie()</code> is possible thanks to <em>tidy evaluation</em> in <a href="https://www.tidyverse.org/articles/2018/07/ggplot2-3-0-0/"><code>{ggplot2}</code></a>, which makes it possible to write a function that passes data frame columns down to <code>aes()</code>. Before version 3.0 of <code>{ggplot2}</code> this was not possible, and writing such a function would have been a bit more complicated. Now, it’s as easy as pie, if I dare say.
</p>
<p>
Something else I want to look at, is the distribution of turns by role:
</p>
<pre class="r"><code>nethack %&gt;%
  filter(turns &lt; quantile(turns, 0.98)) %&gt;%
  ggplot(aes(x = turns, y = role, group = role, fill = role)) +
    geom_density_ridges(scale = 6, size = 0.25, rel_min_height = 0.01) + 
    theme_blog() + 
    scale_fill_blog() + 
    theme(axis.text.y = element_blank(),
          axis.title.y = element_blank())</code></pre>
<pre><code>## Picking joint bandwidth of 486</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-13-1.png" width="80%" height="auto">
</div>
<p>
I use the very cool <code>{ggridges}</code> package for that. The distribution seems to mostly be the same (of course, one should do a statistical test to be sure), but the one for the role “Valkyrie” seems to be quite different from the others. It is known that it is easier to win the game playing as a Valkyrie, but a question remains: is it really easier as a Valkyrie, or do good players tend to play as Valkyries more often?
</p>
</section>
<section id="creatures-vanquished-genocided-or-extinct" class="level2">
<h2 class="anchored" data-anchor-id="creatures-vanquished-genocided-or-extinct">
Creatures vanquished, genocided or extinct
</h2>
<p>
The dumplog lists which, and how many of which, creatures were vanquished during the run, as well as creatures that were genocided and extinct. The player can genocide an entire species by reading a <em>scroll of genocide</em> (or by sitting on a throne). A species gets extinct if the player manages to kill every monster from that species (there’s other ways too, but for the sake of simplicity, let’s just say that when the players kills every monster from a species, the species is extinct). The following lines are an extract of a dumplog:
</p>
<pre><code>"Vanquished creatures:"
"    Baalzebub"
"    Orcus"
"    Juiblex"
"the Wizard of Yendor (4 times)"
"    Pestilence (thrice)"
"    Famine"
"    Vlad the Impaler"
"  4 arch-liches"
"  an arch-lich"
"  a high priest"
"..."
"..."
"..."
"2873 creatures vanquished." </code></pre>
<p>
If I want to analyze this, I have to first solve some problems:
</p>
<ul>
<li>
Replace “a” and “an” by “1”
</li>
<li>
Put the digit in the string “(4 times)” in front of the name of the monster (going from “the Wizard of Yendor (4 times)” to “4 the Wizard of Yendor”)
</li>
<li>
Do something similar for “twice” and “thrice”
</li>
<li>
Put everything into singular (for example, arch-liches into arch-lich)
</li>
<li>
Trim whitespace
</li>
<li>
Extract the genocided or extinct status from the dumplog too
</li>
<li>
Finally, return a data frame with all the needed info
</li>
</ul>
<p>
I wrote a function called <code>extracted_defeated_monsters()</code> and included it in the <code>{nethack}</code> package. I discuss this function in appendix, but what it does is extracting information from dumplog files about vanquished, genocided or extinct monsters and returns a tidy dataframe with that info. This function has a lot of things going on inside it, so if you’re interested in learning more about regular expression and other <code>{tidyverse}</code> tricks, I really encourage you to read its source code.
</p>
<p>
I can now easily add this info to my data:
</p>
<pre class="r"><code>nethack %&lt;&gt;%
  mutate(monsters_destroyed = map(dumplog, ~possibly(extract_defeated_monsters, otherwise = NA)(.)))</code></pre>
<p>
Let’s take a look at one of them:
</p>
<pre class="r"><code>nethack$monsters_destroyed[[117]]</code></pre>
<pre><code>## # A tibble: 285 x 3
##    value monster              status
##    &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt; 
##  1     1 baalzebub            &lt;NA&gt;  
##  2     1 orcu                 &lt;NA&gt;  
##  3     1 juiblex              &lt;NA&gt;  
##  4     4 the wizard of yendor &lt;NA&gt;  
##  5     3 pestilence           &lt;NA&gt;  
##  6     1 famine               &lt;NA&gt;  
##  7     1 vlad the impaler     &lt;NA&gt;  
##  8     4 arch-lich            &lt;NA&gt;  
##  9     1 high priest          &lt;NA&gt;  
## 10     1 medusa               &lt;NA&gt;  
## # ... with 275 more rows</code></pre>
<pre class="r"><code>nethack$monsters_destroyed[[117]] %&gt;% 
  count(status)</code></pre>
<pre><code>## # A tibble: 3 x 2
##   status        n
##   &lt;chr&gt;     &lt;int&gt;
## 1 extinct       2
## 2 genocided     7
## 3 &lt;NA&gt;        276</code></pre>
<p>
The status variable tells us if that monster was genocided or extinct during that run. <code>status</code> equal to “NA” means vanquished.
</p>
<p>
It is now possible to look at, say, the top 15 vanquished monsters (normalized):
</p>
<pre class="r"><code>nethack %&gt;%
  filter(!is.na(monsters_destroyed)) %&gt;%
  pull(monsters_destroyed) %&gt;%
  bind_rows %&gt;%
  group_by(monster) %&gt;%
  summarise(total = sum(value)) %&gt;%
  top_n(15) %&gt;%
  ungroup() %&gt;%
  mutate(norm_total = (total - min(total))/(max(total) - min(total))) %&gt;%
  mutate(monster = fct_reorder(monster, norm_total, .desc = FALSE)) %&gt;%
  ggplot() + 
  geom_col(aes(y = norm_total, x = monster)) + 
  coord_flip() + 
  theme_blog() + 
  scale_fill_blog() + 
  ylab("Ranking") +
  xlab("Monster")</code></pre>
<pre><code>## Selecting by total</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-16-1.png" width="80%" height="auto">
</div>
<p>
In this type of graph, the most vanquished monster, “gnome” has a value of 1, and the least vanquished one, 0. This normalization step is also used in the pre-processing step of machine learning algorithms. This helps convergence of the gradient descent algorithm for instance.
</p>
<p>
Monsters can also get genocided or extinct. Let’s make a pie chart of the proportion of genocided and extinct monsters (I lump monsters that are genocided or extinct less than 5% of the times into a category called other). Because I want two pie charts, I nest the data after having grouped it by the status variable. This is a trick I discussed in this blog <a href="../posts/2017-03-29-make-ggplot2-purrr.html">post</a> and that I use very often:
</p>
<pre class="r"><code>nethack %&gt;%
  filter(!is.na(monsters_destroyed)) %&gt;%
  pull(monsters_destroyed) %&gt;%
  bind_rows %&gt;%
  filter(!is.na(status)) %&gt;%
  group_by(status) %&gt;% 
  count(monster) %&gt;% 
  mutate(monster = fct_lump(monster, prop = 0.05, w = n)) %&gt;% 
  group_by(status, monster) %&gt;% 
  summarise(total_count = sum(n)) %&gt;%
  mutate(freq = total_count/sum(total_count),
         labels = scales::percent(freq)) %&gt;%
  arrange(desc(freq)) %&gt;%
  group_by(status) %&gt;%
  nest() %&gt;%
  mutate(pie_chart = map2(.x = status,
                          .y = data,
                          ~ggplot(data = .y,
                                  aes(x = "", y = freq, fill = (monster))) + 
    geom_col() + 
    ggrepel::geom_label_repel(aes(label = labels), position = position_stack(vjust = 0.25), show.legend = FALSE) + 
    coord_polar("y") + 
    theme_blog() + 
    scale_fill_blog() + 
      ggtitle(.x) +
    theme(legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank())
  )) %&gt;%
  pull(pie_chart)</code></pre>
<pre><code>## Warning in mutate_impl(.data, dots): Unequal factor levels: coercing to
## character</code></pre>
<pre><code>## Warning in mutate_impl(.data, dots): binding character and factor vector,
## coercing into character vector

## Warning in mutate_impl(.data, dots): binding character and factor vector,
## coercing into character vector</code></pre>
<pre><code>## [[1]]</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-17-1.png" width="80%" height="auto">
</div>
<pre><code>## 
## [[2]]</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-17-2.png" width="80%" height="auto">
</div>
<p>
That was it for this one, the graphs are not that super sexy, but the amount of work that went into making them was quite consequent. The main reason was that parsing xlogfiles was a bit tricky, but the main challenge was extracting information from dumplog files. This proved to be a bit more complicated than expected (just take a look at the source code of <code>extract_defeated_monsters()</code> to get an idea…).
</p>
</section>
<section id="bonus-plot" class="level2">
<h2 class="anchored" data-anchor-id="bonus-plot">
Bonus plot
</h2>
<section id="correct-number-of-daily-games" class="level3">
<h3 class="anchored" data-anchor-id="correct-number-of-daily-games">
Correct number of daily games
</h3>
<p>
The daily number of games are available <a href="https://alt.org/nethack/dailygames_ct.html">here</a>. Let’s extract this info and remake the plot that shows the number of runs per day:
</p>
<pre class="r"><code>games &lt;- read_html("https://alt.org/nethack/dailygames_ct.html") %&gt;%
        html_nodes(xpath = '//table') %&gt;%
        html_table(fill = TRUE) </code></pre>
<p>
This extracts all the tables and puts them into a list. Let’s take a look at one:
</p>
<pre class="r"><code>head(games[[1]])</code></pre>
<pre><code>##   2018  2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018
## 1         NA    1    2    3    4    5    6    7    8    9   10   11   12
## 2  Jan 11639  275  370  394  363  392  276  288  324  297  411  413  430
## 3  Feb 10819  375  384  359  376  440  345  498  457  416  376  421  416
## 4  Mar 12148  411  403  421  392  447  391  451  298  350  309  309  369
## 5  Apr 13957  456  513  482  516  475  490  397  431  436  438  541  493
## 6  May 13361  595  509  576  620  420  443  407  539  440  446  404  282
##   2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018
## 1   13   14   15   16   17   18   19   20   21   22   23   24   25   26
## 2  331  341  318  483  408  424  464  412  371  430  348  315  359  375
## 3  385  367  443  324  283  341  385  398  361  379  399  276  455  460
## 4  390  358  362  345  388  360  411  382  371  400  410  417  328  431
## 5  593  537  396  578  403  435  526  448  339  377  476  492  528  393
## 6  265  358  419  564  483  429  423  299  424  404  450  408  355  409
##   2018 2018 2018 2018 2018
## 1   27   28   29   30   31
## 2  432  371  385  440  399
## 3  353  347   NA   NA   NA
## 4  386  484  493  486  395
## 5  407  421  463  477   NA
## 6  417  433  360  391  389</code></pre>
<p>
Let’s clean this up.
</p>
<pre class="r"><code>clean_table &lt;- function(df){
  # Promotes first row to header
  colnames(df) &lt;- df[1, ]
  df &lt;- df[-1, ]
  
  # Remove column with total from the month
  df &lt;- df[, -2]
  
  # Name the first column "month"
  
  colnames(df)[1] &lt;- "month"
  
  # Now put it in a tidy format
  df %&gt;%
    gather(day, games_played, -month)
}</code></pre>
<p>
Now I can clean up all the tables. I apply this function to each element of the list <code>games</code>. I also add a year column:
</p>
<pre class="r"><code>games &lt;- map(games, clean_table) %&gt;%
  map2_dfr(.x = ., 
       .y = seq(2018, 2001),
       ~mutate(.x, year = .y))</code></pre>
<p>
Now I can easily create the plot I wanted
</p>
<pre class="r"><code>games %&lt;&gt;%
  mutate(date = lubridate::ymd(paste(year, month, day, sep = "-")))</code></pre>
<pre><code>## Warning: 122 failed to parse.</code></pre>
<pre class="r"><code>ggplot(games, aes(y = games_played, x = date)) + 
  geom_point(colour = "#0f4150") + 
  geom_smooth(colour = "#82518c") + 
  theme_blog() + 
  ylab("Total games played")</code></pre>
<pre><code>## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'</code></pre>
<pre><code>## Warning: Removed 452 rows containing non-finite values (stat_smooth).</code></pre>
<pre><code>## Warning: Removed 452 rows containing missing values (geom_point).</code></pre>
<div style="text-align: center;">
<img src="../assets/img/nethack_analysis_part2-22-1.png" width="80%" height="auto">
</div>
<p>
There’s actually a lot more games than 50 per day being played!
</p>
</section>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">
Appendix
</h2>
<section id="fuzzy-matching" class="level3">
<h3 class="anchored" data-anchor-id="fuzzy-matching">
Fuzzy matching
</h3>
<p>
If you take a look at the <code>extract_defeated_monsters()</code> source code, you’ll see that at some point I “singularize” monster names. I decided to deal with this singular/plural issue, “by hand”, but also explored other possibilities, such as matching the plural nouns with the singular nouns fuzzily. In the end it didn’t work out so well, but here’s the code for future reference.
</p>
<pre class="r"><code>monster_list &lt;- read_html("https://nethackwiki.com/wiki/Monsters_(by_difficulty)") %&gt;%
    html_nodes(".prettytable") %&gt;% 
    .[[1]] %&gt;%
    html_table(fill = TRUE)

monster_list %&lt;&gt;%
    select(monster = Name)

head(monster_list)</code></pre>
<pre><code>##      monster
## 1 Demogorgon
## 2   Asmodeus
## 3  Baalzebub
## 4   Dispater
## 5     Geryon
## 6      Orcus</code></pre>
<pre class="r"><code>library(fuzzyjoin)

test_vanquished &lt;- extract_defeated_monsters(nethack$dumplog[[117]])

head(test_vanquished)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   value monster              status
##   &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt; 
## 1     1 baalzebub            &lt;NA&gt;  
## 2     1 orcu                 &lt;NA&gt;  
## 3     1 juiblex              &lt;NA&gt;  
## 4     4 the wizard of yendor &lt;NA&gt;  
## 5     3 pestilence           &lt;NA&gt;  
## 6     1 famine               &lt;NA&gt;</code></pre>
<p>
You can take a look at the result by expanding:
</p>
<details>
<p>
</p><summary>
Click to expand
</summary>
<p></p>
<pre class="r"><code>stringdist_left_join(test_vanquished, monster_list) %&gt;% 
  count(monster.y) %&gt;%
  print(n = Inf)</code></pre>
<pre><code>## Joining by: "monster"</code></pre>
<pre><code>## # A tibble: 297 x 2
##     monster.y                   n
##     &lt;chr&gt;                   &lt;int&gt;
##   1 acid blob                   1
##   2 air elemental               2
##   3 Aleax                       1
##   4 aligned priest              1
##   5 Angel                       1
##   6 ape                         2
##   7 arch-lich                   1
##   8 Baalzebub                   1
##   9 baby black dragon           1
##  10 baby crocodile              1
##  11 baby gray dragon            1
##  12 baby green dragon           1
##  13 baby long worm              1
##  14 baby orange dragon          1
##  15 baby white dragon           1
##  16 baby yellow dragon          1
##  17 balrog                      1
##  18 baluchitherium              1
##  19 barbed devil                1
##  20 barrow wight                1
##  21 bat                         1
##  22 black dragon                1
##  23 black light                 1
##  24 black naga                  1
##  25 black pudding               1
##  26 black unicorn               1
##  27 blue dragon                 1
##  28 blue jelly                  1
##  29 bone devil                  1
##  30 brown mold                  1
##  31 brown pudding               1
##  32 bugbear                     1
##  33 captain                     1
##  34 carnivorous ape             1
##  35 cave spider                 1
##  36 centipede                   1
##  37 chameleon                   1
##  38 chickatrice                 2
##  39 clay golem                  1
##  40 cobra                       1
##  41 cockatrice                  2
##  42 couatl                      1
##  43 coyote                      1
##  44 crocodile                   1
##  45 demilich                    1
##  46 dingo                       1
##  47 disenchanter                1
##  48 dog                         1
##  49 doppelganger                1
##  50 dust vortex                 1
##  51 dwarf                       2
##  52 dwarf king                  1
##  53 dwarf lord                  1
##  54 dwarf mummy                 1
##  55 dwarf zombie                1
##  56 earth elemental             1
##  57 electric eel                1
##  58 elf                         1
##  59 elf mummy                   1
##  60 elf zombie                  1
##  61 elf-lord                    1
##  62 Elvenking                   1
##  63 energy vortex               1
##  64 erinys                      1
##  65 ettin                       1
##  66 ettin mummy                 1
##  67 ettin zombie                1
##  68 Famine                      1
##  69 fire ant                    2
##  70 fire elemental              2
##  71 fire giant                  2
##  72 fire vortex                 2
##  73 flaming sphere              1
##  74 flesh golem                 1
##  75 floating eye                1
##  76 fog cloud                   1
##  77 forest centaur              1
##  78 fox                         1
##  79 freezing sphere             1
##  80 frost giant                 1
##  81 gargoyle                    1
##  82 garter snake                1
##  83 gas spore                   1
##  84 gecko                       1
##  85 gelatinous cube             1
##  86 ghost                       2
##  87 ghoul                       2
##  88 giant ant                   3
##  89 giant bat                   3
##  90 giant beetle                1
##  91 giant eel                   1
##  92 giant mimic                 1
##  93 giant mummy                 1
##  94 giant rat                   3
##  95 giant spider                1
##  96 giant zombie                1
##  97 glass piercer               1
##  98 gnome                       1
##  99 gnome king                  1
## 100 gnome lord                  1
## 101 gnome mummy                 1
## 102 gnome zombie                1
## 103 gnomish wizard              1
## 104 goblin                      1
## 105 gold golem                  2
## 106 golden naga                 1
## 107 golden naga hatchling       1
## 108 gray ooze                   1
## 109 gray unicorn                1
## 110 Green-elf                   1
## 111 gremlin                     1
## 112 Grey-elf                    1
## 113 grid bug                    1
## 114 guardian naga               1
## 115 guardian naga hatchling     1
## 116 hell hound                  1
## 117 hell hound pup              1
## 118 hezrou                      1
## 119 high priest                 1
## 120 hill giant                  1
## 121 hill orc                    1
## 122 hobbit                      1
## 123 hobgoblin                   1
## 124 homunculus                  1
## 125 horned devil                1
## 126 horse                       2
## 127 housecat                    1
## 128 human                       1
## 129 human mummy                 1
## 130 human zombie                1
## 131 ice devil                   1
## 132 ice troll                   1
## 133 ice vortex                  2
## 134 iguana                      1
## 135 imp                         1
## 136 incubus                     1
## 137 iron golem                  1
## 138 iron piercer                1
## 139 jabberwock                  1
## 140 jackal                      1
## 141 jaguar                      1
## 142 jellyfish                   1
## 143 Juiblex                     1
## 144 Keystone Kop                1
## 145 ki-rin                      1
## 146 killer bee                  1
## 147 kitten                      1
## 148 kobold                      1
## 149 kobold lord                 1
## 150 kobold mummy                1
## 151 kobold shaman               1
## 152 kobold zombie               1
## 153 Kop Lieutenant              1
## 154 Kop Sergeant                1
## 155 kraken                      2
## 156 large cat                   1
## 157 large dog                   1
## 158 large kobold                1
## 159 large mimic                 1
## 160 leather golem               1
## 161 leocrotta                   1
## 162 leprechaun                  1
## 163 lich                        2
## 164 lichen                      2
## 165 lieutenant                  1
## 166 little dog                  1
## 167 lizard                      1
## 168 long worm                   1
## 169 Lord Surtur                 1
## 170 lurker above                1
## 171 lynx                        1
## 172 manes                       1
## 173 marilith                    1
## 174 master lich                 1
## 175 master mind flayer          1
## 176 Medusa                      1
## 177 mind flayer                 1
## 178 minotaur                    1
## 179 monk                        2
## 180 monkey                      1
## 181 Mordor orc                  1
## 182 mountain centaur            1
## 183 mountain nymph              1
## 184 mumak                       1
## 185 nalfeshnee                  1
## 186 Nazgul                      1
## 187 newt                        1
## 188 Norn                        1
## 189 nurse                       2
## 190 ochre jelly                 1
## 191 ogre                        1
## 192 ogre king                   1
## 193 ogre lord                   1
## 194 Olog-hai                    1
## 195 orange dragon               1
## 196 orc                         3
## 197 orc mummy                   1
## 198 orc shaman                  1
## 199 orc zombie                  1
## 200 orc-captain                 1
## 201 Orcus                       1
## 202 owlbear                     1
## 203 page                        2
## 204 panther                     1
## 205 paper golem                 1
## 206 Pestilence                  1
## 207 piranha                     1
## 208 pit fiend                   1
## 209 pit viper                   1
## 210 plains centaur              1
## 211 pony                        1
## 212 purple worm                 1
## 213 pyrolisk                    1
## 214 python                      1
## 215 quantum mechanic            1
## 216 quasit                      1
## 217 queen bee                   1
## 218 quivering blob              1
## 219 rabid rat                   1
## 220 ranger                      1
## 221 raven                       2
## 222 red dragon                  1
## 223 red mold                    1
## 224 red naga                    1
## 225 rock mole                   1
## 226 rock piercer                1
## 227 rock troll                  1
## 228 rogue                       2
## 229 rope golem                  1
## 230 roshi                       1
## 231 rothe                       1
## 232 rust monster                1
## 233 salamander                  1
## 234 sandestin                   1
## 235 sasquatch                   1
## 236 scorpion                    1
## 237 sergeant                    1
## 238 sewer rat                   1
## 239 shade                       3
## 240 shark                       2
## 241 shocking sphere             1
## 242 shrieker                    1
## 243 silver dragon               1
## 244 skeleton                    1
## 245 small mimic                 1
## 246 snake                       2
## 247 soldier                     1
## 248 soldier ant                 1
## 249 spotted jelly               1
## 250 stalker                     1
## 251 steam vortex                1
## 252 stone giant                 2
## 253 stone golem                 1
## 254 storm giant                 2
## 255 straw golem                 1
## 256 succubus                    1
## 257 tengu                       1
## 258 tiger                       1
## 259 titanothere                 1
## 260 trapper                     1
## 261 troll                       1
## 262 umber hulk                  1
## 263 Uruk-hai                    1
## 264 vampire                     1
## 265 vampire bat                 1
## 266 vampire lord                1
## 267 violet fungus               1
## 268 Vlad the Impaler            1
## 269 vrock                       1
## 270 warg                        2
## 271 warhorse                    1
## 272 water elemental             1
## 273 water moccasin              1
## 274 water nymph                 1
## 275 werejackal                  2
## 276 wererat                     2
## 277 werewolf                    2
## 278 white dragon                1
## 279 white unicorn               1
## 280 winged gargoyle             1
## 281 winter wolf                 1
## 282 winter wolf cub             1
## 283 wizard                      1
## 284 wolf                        1
## 285 wood golem                  2
## 286 wood nymph                  1
## 287 Woodland-elf                1
## 288 wraith                      1
## 289 wumpus                      1
## 290 xan                         3
## 291 xorn                        2
## 292 yellow dragon               1
## 293 yellow light                1
## 294 yellow mold                 1
## 295 yeti                        1
## 296 zruty                       1
## 297 &lt;NA&gt;                        1</code></pre>
</details>
<p>
As you can see, some matches fail, especially for words that end in “y” in the singular, so “ies” in plural, or “fire vortices” that does not get matched to “fire vortex”. I tried all the methods but it’s either worse, or marginally better.
</p>
</section>
<section id="extracting-info-from-dumplogfiles" class="level3">
<h3 class="anchored" data-anchor-id="extracting-info-from-dumplogfiles">
Extracting info from dumplogfiles
</h3>
<details>
<p>
</p><summary>
Click here to take a look at the source code from extract_defeated_monsters
</summary>
<p></p>
<pre class="r"><code>#' Extract information about defeated monsters from an xlogfile
#' @param xlog A raw xlogfile
#' @return A data frame with information on vanquished, genocided and extincted monsters
#' @importFrom dplyr mutate select filter bind_rows full_join
#' @importFrom tidyr separate
#' @importFrom tibble as_tibble tibble
#' @importFrom magrittr "%&gt;%"
#' @importFrom purrr map2 possibly is_empty modify_if simplify discard
#' @importFrom readr read_lines
#' @importFrom stringr str_which str_replace_all str_replace str_trim str_detect str_to_lower str_extract_all str_extract
#' @export
#' @examples
#' \dontrun{
#' get_dumplog(xlog)
#' }
extract_defeated_monsters &lt;- function(dumplog){

    if(any(str_detect(dumplog, "No creatures were vanquished."))){
        return(NA)
    } else {

        start &lt;- dumplog %&gt;% # &lt;- dectect the start of the list
            str_which("Vanquished creatures")

        end &lt;- dumplog %&gt;% # &lt;- detect the end of the list
            str_which("\\d+ creatures vanquished.")

        if(is_empty(end)){ # This deals with the situation of only one vanquished creature
            end &lt;- start + 2
        }

        list_creatures &lt;- dumplog[(start + 1):(end - 1)] %&gt;% # &lt;- extract the list
            str_replace_all("\\s+an? ", "1 ") %&gt;% # &lt;- replace a or an by 1
            str_trim() # &lt;- trim white space

        # The following function first extracts the digit in the string (123 times)
        # and replaces the 1 with this digit
        # This means that: "1 the Wizard of Yendor (4 times)" becomes "4 the Wizard of Yendor (4 times)"
        str_extract_replace &lt;- function(string){
            times &lt;- str_extract(string, "\\d+(?=\\stimes)")
            str_replace(string, "1", times)
        }

        result &lt;- list_creatures %&gt;%
            # If a string starts with a letter, add a 1
            # This means that: "Baalzebub" becomes "1 Baalzebub"
            modify_if(str_detect(., "^[:alpha:]"), ~paste("1", .)) %&gt;%
            # If the string "(twice)" is detected, replace "1" (that was added the line before) with "2"
            modify_if(str_detect(., "(twice)"), ~str_replace(., "1", "2")) %&gt;%
            # Same for "(thrice)"
            modify_if(str_detect(., "(thrice)"), ~str_replace(., "1", "3")) %&gt;%
            # Exctract the digit in "digit times" and replace the "1" with digit
            modify_if(str_detect(., "(\\d+ times)"), str_extract_replace) %&gt;%
            # Replace "(times)" or "(twice)" etc with ""
            str_replace_all("\\(.*\\)", "") %&gt;%
            str_trim() %&gt;%
            simplify() %&gt;%
            # Convert the resulting list to a tibble. This tibble has one column:
            # value
            # 1 Baalzebub
            # 2 dogs
            #...
            as_tibble() %&gt;%
            # Use tidyr::separate to separate the "value" column into two columns. The extra pieces get merged
            # So for example "1 Vlad the Impaler" becomes "1" "Vlad the Impaler" instead of "1" "Vlad" which
            # would be the case without "extra = "merge""
            separate(value, into = c("value", "monster"), extra = "merge") %&gt;%
            mutate(value = as.numeric(value)) %&gt;%
            mutate(monster = str_to_lower(monster))

        # This function singularizes names:
        singularize_monsters &lt;- function(nethack_data){
            nethack_data %&gt;%
                mutate(monster = str_replace_all(monster, "mummies", "mummy"),
                       monster = str_replace_all(monster, "jellies", "jelly"),
                       monster = str_replace_all(monster, "vortices", "vortex"),
                       monster = str_replace_all(monster, "elves", "elf"),
                       monster = str_replace_all(monster, "wolves", "wolf"),
                       monster = str_replace_all(monster, "dwarves", "dwarf"),
                       monster = str_replace_all(monster, "liches", "lich"),
                       monster = str_replace_all(monster, "baluchiteria", "baluchiterium"),
                       monster = str_replace_all(monster, "homunculi", "homonculus"),
                       monster = str_replace_all(monster, "mumakil", "mumak"),
                       monster = str_replace_all(monster, "sasquatches", "sasquatch"),
                       monster = str_replace_all(monster, "watchmen", "watchman"),
                       monster = str_replace_all(monster, "zruties", "zruty"),
                       monster = str_replace_all(monster, "xes$", "x"),
                       monster = str_replace_all(monster, "s$", ""))
        }

        result &lt;- singularize_monsters(result)
    }
    # If a player did not genocide or extinct any species, return the result:
    if(any(str_detect(dumplog, "No species were genocided or became extinct."))){
        result &lt;- result %&gt;%
            mutate(status = NA_character_)
        return(result)
    } else {

        # If the player genocided or extincted species, add this info:
        start &lt;- dumplog %&gt;% # &lt;- dectect the start of the list
            str_which("Genocided or extinct species:") # &lt;- sometimes this does not appear in the xlogfile

        end &lt;- dumplog %&gt;% # &lt;- detect the end of the list
            str_which("Voluntary challenges")

       if(is_empty(start)){# This deals with the situation start does not exist
           start &lt;- end - 2
       }

        list_creatures &lt;- dumplog[(start + 1):(end - 1)] %&gt;% # &lt;- extract the list
            str_trim() # &lt;- trim white space

        extinct_species &lt;- list_creatures %&gt;%
            str_extract_all("[:alpha:]+\\s(?=\\(extinct\\))", simplify = T) %&gt;%
            str_trim %&gt;%
            discard(`==`(., ""))

        extinct_species_df &lt;- tibble(monster = extinct_species, status = "extinct")

        genocided_species_index &lt;- list_creatures %&gt;%
            str_detect(pattern = "extinct|species") %&gt;%
            `!`

        genocided_species &lt;- list_creatures[genocided_species_index]

        genocided_species_df &lt;- tibble(monster = genocided_species, status = "genocided")

        genocided_or_extinct_df &lt;- singularize_monsters(bind_rows(extinct_species_df, genocided_species_df))

        result &lt;- full_join(result, genocided_or_extinct_df, by = "monster") %&gt;%
            filter(monster != "") # &lt;- this is to remove lines that were added by mistake, for example if start was empty

        return(result)
    }
}</code></pre>
</details>
</section>
</section>



</main> <!-- /main -->
<hr style="border: 1px solid #ccc; margin: 20px 0;">
<footer>
If you find the content in this blog useful, you might want to follow
me on <a href="https://fosstodon.org/@brodriguesco">Mastodon</a> or <a href="https://www.twitter.com/brodriguesco">twitter</a> for blog post updates or
<a href="https://www.buymeacoffee.com/brodriguesco">buy me an espresso</a> or <a href="https://www.paypal.me/brodriguesco">paypal.me</a>, or buy my <a href="../books.html">ebooks</a>.
You can also watch my videos on <a href="https://www.youtube.com/c/BrunoRodrigues1988/">youtube</a>.
So much content for you to consoom!
<p></p>
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style>
<p>
<link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/brodriguesco"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me an Espresso"><span style="margin-left:5px">Buy me an Espresso</span></a>
</p>
  <div class="row">
    <div class="col-lg-12">
        <p>© <span id="year"></span>, content by Bruno Rodrigues, unless otherwise stated, every content of this blog is licensed under the <a href="http://www.wtfpl.net/txt/copying/" rel="nofollow">WTFPL</a>.</p>
        <p>Built with <a href="https://quarto.org/">Quarto</a> and <a href="https://nixos.org/explore/">Nix</a>, hosted on <a href="https://pages.github.com/">GitHub Pages</a>.</p>
      <p><a href="../index.html">Back to main page.</a></p>
    </div>
  </div>
</footer>
<script>
 document.getElementById('year').textContent = new Date().getFullYear();
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/b-rodrigues\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>