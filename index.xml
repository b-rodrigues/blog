<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Econometrics and Free Software</title>
<link>https://b-rodrigues.github.io/</link>
<atom:link href="https://b-rodrigues.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.6.37</generator>
<lastBuildDate>Wed, 29 Oct 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>Of course, someone has to write imperative code to build reproducible data science pipelines. It doesn’t have to be you.</title>
  <link>https://b-rodrigues.github.io/posts/2025-10-29-imperative-vs-function.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/xkcd-nix.png" style="width: 100%; height: auto;"> </a>
</p>
</div>
<p><a href="https://brodrigues.co/posts/2025-10-23-rixpress_cran.html">Last time</a> I quickly introduced my latest package, <code>{rixpress}</code>, but I think that to really understand what <code>{rixpress}</code> brings to the table, one needs to solve the same problem without it. And incidentally, I think that this exercise also show what makes Nix actually so good.</p>
<p>The goal is to build a data science pipeline. The example here is purely illustrative, and compare a Nix-based approach to a non Nix-based approach. So, I built the same polyglot Real Business Cycle model pipeline twice. First, I did it without <code>{rixpress}</code> (nor <code>{rix}</code>), using a combination of Docker, Make, and a bunch of wrapper scripts. Then, I did it with <code>{rix}</code> and <code>{rixpress}</code>.</p>
<p>Both pipelines produce the exact same result. But the way to get there is fundamentally different.</p>
<section id="juggling-imperative-tools" class="level2">
<h2 class="anchored" data-anchor-id="juggling-imperative-tools">Juggling imperative tools</h2>
<p>Without Nix, you have to use language-specific package managers and tooling to first set up the environment. So for Python I’ve used <code>uv</code> (which is fantastic to be honest), then to install the right version of R I’ve used <code>rig</code> and a Posit CRAN snapshot for packages and for Julia I’ve simply downloaded a pre-compiled package of the version I needed, and used its built-in package manager to install specific versions of packages as well.</p>
<p>Also, to deal with system level dependencies, I’ve bundled everything inside a Docker image. This is a sketch of the <code>Dockerfile</code>:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode dockerfile code-with-copy"><code class="sourceCode dockerfile"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Add R repository and install specific version</span></span>
<span id="cb1-2"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> update <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">&amp;&amp;</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">apt-get</span> install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-y</span> software-properties-common</span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">add-apt-repository</span> ppa:...</span>
<span id="cb1-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">curl</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-L</span> https://rig.r-pkg.org/... <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sh</span></span>
<span id="cb1-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">rig</span> add 4.5.1</span>
<span id="cb1-6"></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install Python with uv</span></span>
<span id="cb1-8"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">curl</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-LsSf</span> https://astral.sh/uv/install.sh <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sh</span></span>
<span id="cb1-9"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">uv</span> python install 3.13</span>
<span id="cb1-10"></span>
<span id="cb1-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Download and extract Julia</span></span>
<span id="cb1-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">curl</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-fsSL</span> https://julialang-s3.julialang.org/... <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> julia.tar.gz</span>
<span id="cb1-13"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-xzf</span> julia.tar.gz <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-C</span> /opt/</span>
<span id="cb1-14"></span>
<span id="cb1-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install packages for each language separately</span></span>
<span id="cb1-16"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'options(repos = c(CRAN = ...))'</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> /root/.Rprofile</span>
<span id="cb1-17"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Rscript</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-e</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'install.packages(...)'</span></span>
<span id="cb1-18"></span>
<span id="cb1-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install Python packages using uv with specific versions for reproducibility.</span></span>
<span id="cb1-20"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"pandas==2.3.3"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> /tmp/requirements.txt <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">&amp;&amp;</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb1-21">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"scikit-learn==1.7.2"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> /tmp/requirements.txt <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">&amp;&amp;</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb1-22">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ... more packages ...</span></span>
<span id="cb1-23"></span>
<span id="cb1-24"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">uv</span> pip install <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--no-cache</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-r</span> /tmp/requirements.txt <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">&amp;&amp;</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb1-25">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rm</span> /tmp/requirements.txt</span>
<span id="cb1-26"></span>
<span id="cb1-27"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install specific versions of Julia packages for reproducibility</span></span>
<span id="cb1-28"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">julia</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-e</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'using Pkg; \</span></span>
<span id="cb1-29"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    Pkg.add(name="Arrow", version="2.8.0"); \</span></span></code></pre></div>
<p>This <em>traditional</em> approach feels like you’re a sysadmin first and a data scientist second. The <code>Dockerfile</code> is a long, step-by-step, imperative script of shell commands. You have to write <em>how</em> stuff needs to be installed, and this of course varies for each language. Each language needs its own special treatment, its own package installation command, and its own set of dependencies. For example, for Python, I actually even needed more configuration than what I’ve shown above:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode dockerfile code-with-copy"><code class="sourceCode dockerfile"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Ensure the installed binary is on the `PATH`</span></span>
<span id="cb2-2"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">ENV</span> PATH=<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/root/.local/bin/:$PATH"</span></span>
<span id="cb2-3"></span>
<span id="cb2-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install the specified Python version using uv.</span></span>
<span id="cb2-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">uv</span> python install <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">${PYTHON_VERSION}</span></span>
<span id="cb2-6"></span>
<span id="cb2-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Setup default virtual env</span></span>
<span id="cb2-8"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">RUN</span> <span class="ex" style="color: null;
background-color: null;
font-style: inherit;">uv</span> venv /opt/venv</span>
<span id="cb2-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Use the virtual environment automatically</span></span>
<span id="cb2-10"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">ENV</span> VIRTUAL_ENV=/opt/venv</span>
<span id="cb2-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Place entry points in the environment at the front of the path</span></span>
<span id="cb2-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">ENV</span> PATH=<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/opt/venv/bin:$PATH"</span></span></code></pre></div>
<p>This is because I needed to set the virtual environment installed by <code>uv</code> as the one to be used by default. This is ok inside Docker, but that’s not something you’d likely want to do on a real machine. The final <code>Dockerfile</code> for our “simple” example was over 100 lines long (including comments).</p>
<p>Now that the environment is said, we actually need to orchestrate the workflow. I’ve used <code>Make</code> for this, which means writing a <code>Makefile</code>. Honestly, nowadays, thanks to LLMs that’s not so much of an issue. But before LLMs, it would be quite annoying, because you need to manually define which file depends on which other file. Here’s what it looks like:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode makefile code-with-copy"><code class="sourceCode makefile"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ==============================================================================</span></span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Makefile for the Polyglot RBC Model Pipeline</span></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ==============================================================================</span></span>
<span id="cb3-4"></span>
<span id="cb3-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define the interpreters for each language.</span></span>
<span id="cb3-6"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">JULIA</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> julia</span></span>
<span id="cb3-7"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">PYTHON</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> python</span></span>
<span id="cb3-8"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">RSCRIPT</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> Rscript</span></span>
<span id="cb3-9"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">QUARTO</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> quarto</span></span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define directory variables for better organization.</span></span>
<span id="cb3-12"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATA_DIR</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> data</span></span>
<span id="cb3-13"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">PLOTS_DIR</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> plots</span></span>
<span id="cb3-14"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">REPORT_DIR</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> report</span></span>
<span id="cb3-15"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">FUNCTIONS_DIR</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> functions</span></span>
<span id="cb3-16"></span>
<span id="cb3-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define the final and intermediate data files.</span></span>
<span id="cb3-18"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">SIMULATED_DATA</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATA_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">/simulated_rbc_data.arrow</span></span>
<span id="cb3-19"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">PREDICTIONS</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATA_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">/predictions.arrow</span></span>
<span id="cb3-20"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">FINAL_PLOT</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">PLOTS_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">/output_plot.png</span></span>
<span id="cb3-21"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">FINAL_REPORT</span> <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">:=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">REPORT_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">/readme.html</span></span>
<span id="cb3-22"></span>
<span id="cb3-23"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># --- Main Rules ---</span></span>
<span id="cb3-24"></span>
<span id="cb3-25"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The default 'all' rule now points to the final compiled HTML report.</span></span>
<span id="cb3-26"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">all:</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;"> </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">FINAL_REPORT</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb3-27"></span>
<span id="cb3-28"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rule to render the final Quarto report.</span></span>
<span id="cb3-29"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Depends on the Quarto source file and the plot from the R step.</span></span>
<span id="cb3-30"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$(FINAL_REPORT):</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;"> readme.qmd </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">FINAL_PLOT</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;"> | </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">REPORT_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb3-31"><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">    </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">@</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">echo </span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"--- [Quarto] Compiling final report ---"</span></span>
<span id="cb3-32">    <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">QUARTO</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span> render <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$&lt;</span> --to html --output-dir <span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">$(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">REPORT_DIR</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb3-33"></span>
<span id="cb3-34">... and so on ...</span></code></pre></div>
<p>That’s another 65 lines for the orchestration.</p>
<p>Finally, and probably worst of all, is that you end up writing tons of “glue code.” Because <code>make</code> just runs scripts, every step of your analysis (the Julia simulation, the Python training) needs to be wrapped in a script that does nothing but parse command-line arguments, read an input file, call your <em>actual</em> analysis function, and write an output file. That’s a lot of code just to get things talking to each other.</p>
<p>The final tally for the traditional, imperative, approach? <strong>Nine separate files</strong> just to manage the environment and run the pipeline. It’s a fragile, complicated house of cards, but it takes only 3 minutes to run on a standard Ubuntu GitHub Actions runner.</p>
</section>
<section id="nix-declarative-simple-and-clean" class="level2">
<h2 class="anchored" data-anchor-id="nix-declarative-simple-and-clean">Nix: Declarative, Simple, and Clean</h2>
<p>Nix makes this whole process so much easier, it’s actually not even fair. Instead of telling the computer <em>how</em> to do everything, you just declare <em>what</em> you want. You describe your requirements, and Nix figures the rest out. But because Nix is not that easy to get into, I wrotk the <code>{rix}</code> and <code>{rixpress}</code> packages as high-level interfaces to Nix’s power.</p>
<p>For example, to set up the environment, you just list the R, Python, and Julia packages you need, and <code>{rix}</code> handles everything else. It figures out how to install them, resolves all the system-level dependencies, and generates the complex Nix expression for you. You don’t need to be a sysadmin; you just need to know what packages your analysis requires. This is because all the <em>sysadminy</em> work was handled upstream by Nix package maintainers (real MVPs); Nix maintainers encode the build recipes, dependency graphs, and patches needed for each package, so you don’t have to. (Reminds me of this quote from <a href="https://speakerdeck.com/jennybc/row-oriented-workflows-in-r-with-the-tidyverse?slide=16">Jenny Bryan</a>: <em>Of course, someone has to write for loops. It doesn’t have to be you</em>, but here it’s unglamorous Nix code to make packages work well instead of loops.)</p>
<p>Here’s what the <code>gen-env.R</code> script looks like:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rix</span>(</span>
<span id="cb4-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">date =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"2025-10-14"</span>,</span>
<span id="cb4-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">r_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ggplot2"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"arrow"</span>),</span>
<span id="cb4-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">jl_conf =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">jl_version =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"lts"</span>, ...),</span>
<span id="cb4-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_conf =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_version =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"3.13"</span>, ...),</span>
<span id="cb4-6">  ...</span>
<span id="cb4-7">)</span></code></pre></div>
<p>Then, for the pipeline, it’s the same story. You just write what you need, not how it’s done. Nix can handle this. Here’s what the <code>gen-pipeline.R</code> script looks like:</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">/</span> gen<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>pipeline.R <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> a small part</span>
<span id="cb5-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb5-3">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> simulated_rbc_data, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"simulate_rbc_model(...)"</span>),</span>
<span id="cb5-4">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> predictions, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"train_model(simulated_rbc_data)"</span>),</span>
<span id="cb5-5">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> output_plot, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"plot_predictions(predictions)"</span>),</span>
<span id="cb5-6">  ...</span>
<span id="cb5-7">)</span></code></pre></div>
<p>Dependencies are inferred automatically. <code>{rixpress}</code> sees that <code>predictions</code> uses the <code>simulated_rbc_data</code> object and knows to run the Julia step first. It handles all the I/O for you as well. Objects get serialised and unserialised transparently for you.</p>
<p>Your scientific code now lives in pure functions, free of any command-line parsing or file I/O. You can focus entirely on the analysis.</p>
<p>The final tally for the Nix-based approach? <strong>Six files</strong>, and four of them (<code>gen-env.R</code>, <code>gen-pipeline.R</code>, and the two <code>functions</code> files) are simple, clean declarations of what you need and what you want to do. The whole set up of the environment and execution of the pipeline takes 5 minutes on a standard GitHub Actions runner. That’s 2 minutes longer that the imperative approach, but I think it’s a small price to pay. Plus, you’re not setting up the environment from scratch each time you execute the pipeline, so subsequent executions will only take seconds.</p>
<p>The biggest difference isn’t just the simplicity; it’s the guarantee. The Docker approach gives you reproducibility <em>today</em>. But a year from now, if you rebuild the <code>Dockerfile</code>, mutable base images and shifting package dependencies mean you might get a subtly different environment. The underlying base Docker image will change, and in some years, will completely stop functioning (Ubuntu 24.04, which is quite often used as the base image, will reach of end of life in 2029).</p>
<p>The Nix approach, by pinning everything to a specific date, gives you <strong>temporal reproducibility</strong>. Your environment will build the exact same way today, next year, or five years from now, for as long as the <code>nixpkgs</code> GitHub repository will stay online (we can hope for a 1000 years if Microsoft doesn’t fuck it up). It’s a level of long-term stability that the traditional stack simply can’t match without a heroic amount of manual effort. But also, it’s just so much <em>simpler</em>!</p>


</section>

 ]]></description>
  <category>R</category>
  <category>Nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-10-29-imperative-vs-function.html</guid>
  <pubDate>Wed, 29 Oct 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress}</title>
  <link>https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/polyglot-dag.png" style="width: 100%; height: auto;"> </a>
</p>
</div>
<p><em>TL;DR: <code>{rixpress}</code> lets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI!</em></p>
<p><code>{rixpress}</code> is now on CRAN! As discussed in previous blog posts, <code>{rixpress}</code> is a package heavily inspired by <code>{targets}</code> that uses Nix as the underlying build automation tool to build reproducible data science pipelines.</p>
<p>But I also wanted <code>{rixpress}</code> to be a language-agnostic build automation tool: pipelines do get defined as an R list, but they can include R, Julia and Python <em>derivations</em> (think of a derivation as a build step).</p>
<p><code>{rixpress}</code> allows you to define and execute complex, multi-language pipelines where each step runs in its own perfectly reproducible, hermetically sealed environment.</p>
<p>Because installing stuff is so easy with Nix, the cost of using Python or Julia for a project is really low. Before Nix, I’d try my hardest to find equivalent R packages, just to avoid having to setup a Python environment, but now, if I really have to use Python, I don’t mind that much (also because since I can delegate writing Python to an LLM).</p>
<p>Suppose you have a project that uses Julia, Python and R: without Nix, <code>{rix}</code> and <code>{rixpress}</code>, setting everything up and executing the code is going to be quite annoying. But with the aforementioned tools? Easy as pie.</p>
<p>Let’s consider an example from economics, where Julia is used to define a structural Real Business Cycle model (and simulate data from it), Python (with its package <code>xgboost</code>) is used to make predictions from the simulated data, and R to visualise, using <code>{ggplot2}</code>. In truth, one could have use just one of these three languages, but for the sake of argument, let’s use them all.</p>
<p>With <code>{rixpress}</code>, this entire polyglot workflow is defined declaratively in a single R script. Each step is a function call, making the pipeline easy to read and manage.</p>
<p>Start the project with <code>rixpress::rxp_init()</code>, which generates two files, <code>gen-env.R</code> and <code>gen-pipeline.R</code>. In <code>gen-env.R</code>, you’ll define the environment you need:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(rix)</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rix</span>(</span>
<span id="cb1-4">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Pin the environment to a specific date to ensure that all package</span></span>
<span id="cb1-5">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># versions are resolved as they were on this day.</span></span>
<span id="cb1-6">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">date =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"2025-10-14"</span>,</span>
<span id="cb1-7"></span>
<span id="cb1-8">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. R Packages</span></span>
<span id="cb1-9">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We need packages for plotting, data manipulation, and reading arrow files.</span></span>
<span id="cb1-10">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We also include reticulate as it can be useful for rixpress internals.</span></span>
<span id="cb1-11">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">r_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(</span>
<span id="cb1-12">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ggplot2"</span>,</span>
<span id="cb1-13">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ggdag"</span>,</span>
<span id="cb1-14">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr"</span>,</span>
<span id="cb1-15">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"arrow"</span>,</span>
<span id="cb1-16">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"rix"</span>,</span>
<span id="cb1-17">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"rixpress"</span>,</span>
<span id="cb1-18">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"quarto"</span></span>
<span id="cb1-19">  ),</span>
<span id="cb1-20"></span>
<span id="cb1-21">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Julia Configuration</span></span>
<span id="cb1-22">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We specify the Julia version and the list of packages needed</span></span>
<span id="cb1-23">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># for our manual RBC model simulation.</span></span>
<span id="cb1-24">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">jl_conf =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb1-25">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">jl_version =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"lts"</span>,</span>
<span id="cb1-26">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">jl_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(</span>
<span id="cb1-27">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Distributions"</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># For creating random shocks</span></span>
<span id="cb1-28">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"DataFrames"</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># For structuring the output</span></span>
<span id="cb1-29">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Arrow"</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># For saving the data in a cross-language format</span></span>
<span id="cb1-30">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Random"</span></span>
<span id="cb1-31">    )</span>
<span id="cb1-32">  ),</span>
<span id="cb1-33"></span>
<span id="cb1-34">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Python Configuration</span></span>
<span id="cb1-35">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We specify the Python version and the packages needed for the</span></span>
<span id="cb1-36">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># machine learning step.</span></span>
<span id="cb1-37">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_conf =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb1-38">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_version =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"3.13"</span>,</span>
<span id="cb1-39">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(</span>
<span id="cb1-40">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"pandas"</span>,</span>
<span id="cb1-41">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"scikit-learn"</span>,</span>
<span id="cb1-42">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"xgboost"</span>,</span>
<span id="cb1-43">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"pyarrow"</span>,</span>
<span id="cb1-44">      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ryxpress"</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Python port of rixpress</span></span>
<span id="cb1-45">    )</span>
<span id="cb1-46">  ),</span>
<span id="cb1-47"></span>
<span id="cb1-48">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We set the IDE to 'none' for a minimal environment. You could change</span></span>
<span id="cb1-49">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># this to "rstudio" if you prefer to work interactively in RStudio.</span></span>
<span id="cb1-50">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">ide =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"none"</span>,</span>
<span id="cb1-51"></span>
<span id="cb1-52">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define the project path and allow overwriting the default.nix file.</span></span>
<span id="cb1-53">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">project_path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>,</span>
<span id="cb1-54">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">overwrite =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span></span>
<span id="cb1-55">)</span></code></pre></div>
<p>If you are on a system where Nix is available, you can drop into a temporary shell with R and <code>{rix}</code> available to generate the required <code>default.nix</code> (which is the Nix expression that once built, provides the environment):</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">nix-shell</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-I</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-2">  nixpkgs=https://github.com/rstats-on-nix/nixpkgs/tarball/2025-10-20 <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-p</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-3">  R rPackages.rix</span></code></pre></div>
<p>then simply start R, and then <code>source("gen-env.R")</code>. This will generate the <code>default.nix</code>. Then leave R, leave the temporary shell (by typing <code>exit</code> or using <code>CTRL-D</code>) and build the environment with <code>nix-build</code>. Wait for it to finish. Then we can tackle the pipeline. I show the full script below, but you won’t be writing this in one go. Instead, you would add a derivation, build the pipeline, load the artefact into memory by using <code>rxp_load("artefact_name")</code>, look at it, play with it, and then continue. If you’re familiar with <code>{targets}</code> you should feel at ease.</p>
<p>Here’s the full script:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This script defines and orchestrates the entire reproducible analytical</span></span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># pipeline using the {rixpress} package.</span></span>
<span id="cb3-3"></span>
<span id="cb3-4"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(rixpress)</span>
<span id="cb3-5"></span>
<span id="cb3-6"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb3-7">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 0: Define RBC Model Parameters as Derivations</span></span>
<span id="cb3-8">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This makes the parameters an explicit part of the pipeline.</span></span>
<span id="cb3-9">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Changing a parameter will cause downstream steps to rebuild.</span></span>
<span id="cb3-10">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(alpha, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Capital's share of income</span></span>
<span id="cb3-11">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(beta, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.01</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Discount factor</span></span>
<span id="cb3-12">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(delta, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.025</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Depreciation rate</span></span>
<span id="cb3-13">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(rho, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.95</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Technology shock persistence</span></span>
<span id="cb3-14">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(sigma, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Risk aversion (log-utility)</span></span>
<span id="cb3-15">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(sigma_z, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Technology shock standard deviation</span></span>
<span id="cb3-16"></span>
<span id="cb3-17">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 1: Julia - Simulate a Real Business Cycle (RBC) model.</span></span>
<span id="cb3-18">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This derivation runs our Julia script to generate the source data.</span></span>
<span id="cb3-19">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_jl</span>(</span>
<span id="cb3-20">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> simulated_rbc_data,</span>
<span id="cb3-21">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"simulate_rbc_model(alpha, beta, delta, rho, sigma, sigma_z)"</span>,</span>
<span id="cb3-22">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.jl"</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The file containing the function</span></span>
<span id="cb3-23">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">encoder =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"arrow_write"</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The function to use for saving the output</span></span>
<span id="cb3-24">  ),</span>
<span id="cb3-25"></span>
<span id="cb3-26">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 2.1: Python - Prepare features (lagging data)</span></span>
<span id="cb3-27">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-28">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> processed_data,</span>
<span id="cb3-29">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"prepare_features(simulated_rbc_data)"</span>,</span>
<span id="cb3-30">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span>,</span>
<span id="cb3-31">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Decode the Arrow file from Julia into a pandas DataFrame</span></span>
<span id="cb3-32">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">decoder =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"feather.read_feather"</span></span>
<span id="cb3-33">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Note: No encoder needed here. {rixpress} will use pickle by default</span></span>
<span id="cb3-34">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># to pass the DataFrame between Python steps.</span></span>
<span id="cb3-35">  ),</span>
<span id="cb3-36"></span>
<span id="cb3-37">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 2.2: Python - Split data into training and testing sets</span></span>
<span id="cb3-38">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-39">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> X_train,</span>
<span id="cb3-40">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"get_X_train(processed_data)"</span>,</span>
<span id="cb3-41">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-42">  ),</span>
<span id="cb3-43"></span>
<span id="cb3-44">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-45">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> y_train,</span>
<span id="cb3-46">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"get_y_train(processed_data)"</span>,</span>
<span id="cb3-47">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-48">  ),</span>
<span id="cb3-49"></span>
<span id="cb3-50">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-51">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> X_test,</span>
<span id="cb3-52">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"get_X_test(processed_data)"</span>,</span>
<span id="cb3-53">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-54">  ),</span>
<span id="cb3-55"></span>
<span id="cb3-56">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-57">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> y_test,</span>
<span id="cb3-58">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"get_y_test(processed_data)"</span>,</span>
<span id="cb3-59">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-60">  ),</span>
<span id="cb3-61"></span>
<span id="cb3-62">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 2.3: Python - Train the model</span></span>
<span id="cb3-63">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-64">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> trained_model,</span>
<span id="cb3-65">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"train_model(X_train, y_train)"</span>,</span>
<span id="cb3-66">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-67">  ),</span>
<span id="cb3-68"></span>
<span id="cb3-69">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 2.4: Python - Make predictions</span></span>
<span id="cb3-70">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-71">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> model_predictions,</span>
<span id="cb3-72">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"make_predictions(trained_model, X_test)"</span>,</span>
<span id="cb3-73">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span></span>
<span id="cb3-74">  ),</span>
<span id="cb3-75"></span>
<span id="cb3-76">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 2.5: Python - Format final results for R</span></span>
<span id="cb3-77">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-78">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> predictions,</span>
<span id="cb3-79">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"format_results(y_test, model_predictions)"</span>,</span>
<span id="cb3-80">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.py"</span>,</span>
<span id="cb3-81">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We need an encoder here to save the final DataFrame as an Arrow file</span></span>
<span id="cb3-82">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># so the R step can read it.</span></span>
<span id="cb3-83">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">encoder =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"save_arrow"</span></span>
<span id="cb3-84">  ),</span>
<span id="cb3-85"></span>
<span id="cb3-86">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 3: R - Visualize the predictions from the Python model.</span></span>
<span id="cb3-87">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This final derivation depends on the output of the Python step.</span></span>
<span id="cb3-88">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(</span>
<span id="cb3-89">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> output_plot,</span>
<span id="cb3-90">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot_predictions</span>(predictions), <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The function to call from functions.R</span></span>
<span id="cb3-91">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">user_functions =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions/functions.R"</span>,</span>
<span id="cb3-92">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Specify how to load the upstream data (from Python) into R.</span></span>
<span id="cb3-93">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">decoder =</span> arrow<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span>read_feather</span>
<span id="cb3-94">  ),</span>
<span id="cb3-95"></span>
<span id="cb3-96">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># STEP 4: Quarto - Compile the final report.</span></span>
<span id="cb3-97">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_qmd</span>(</span>
<span id="cb3-98">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> final_report,</span>
<span id="cb3-99">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">additional_files =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"_rixpress"</span>,</span>
<span id="cb3-100">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">qmd_file =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"readme.qmd"</span></span>
<span id="cb3-101">  )</span>
<span id="cb3-102">) <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|&gt;</span></span>
<span id="cb3-103">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_populate</span>(</span>
<span id="cb3-104">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_imports =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(</span>
<span id="cb3-105">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">pandas =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"import pandas as pd"</span>,</span>
<span id="cb3-106">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">pyarrow =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"import pyarrow.feather as feather"</span>,</span>
<span id="cb3-107">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">sklearn =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"from sklearn.model_selection import train_test_split"</span>,</span>
<span id="cb3-108">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">xgboost =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"import xgboost as xgb"</span></span>
<span id="cb3-109">    ),</span>
<span id="cb3-110">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">project_path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The root of our project</span></span>
<span id="cb3-111">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">build =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>, <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Set to TRUE to execute the pipeline immediately</span></span>
<span id="cb3-112">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">verbose =</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb3-113">  )</span></code></pre></div>
<p><em>(helper functions are defined in separate scripts, inside the <code>functions/</code> folder which I don’t show here)</em></p>
<p>The magic here is twofold. First, <code>{rixpress}</code> seamlessly handles passing data between language environments, using efficient formats like Apache Arrow via <code>encoder</code> and <code>decoder</code> functions. Second, because each step is a Nix derivation, it runs in its own isolated environment. The Julia simulation can have its own dependencies, completely separate from the Python and R steps, eliminating “dependency hell” forever. Also, the artefacts built by the pipeline are actually children of the environment. Meaning, that if you change the environment (for example, by adding a package), this invalidates everything, and the whole pipeline gets rebuilt. This is quite useful, because sometimes changing the environment could break the downstream artefacts in subtle ways, but with classical build automation tools, the artefacts and the environment are not tied, and so a rebuild would not be triggered.</p>
<p>Once built, you can interactively explore artifacts:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># From R</span></span>
<span id="cb4-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_load</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"simulated_rbc_data"</span>)</span>
<span id="cb4-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_load</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"output_plot"</span>)</span></code></pre></div>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Or from Python (using ryxpress)</span></span>
<span id="cb5-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> ryxpress <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> rxp_make, rxp_load</span>
<span id="cb5-3">rxp_load(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"predictions"</span>)</span></code></pre></div>
<p>The pipeline automatically caches results, so changing one step only rebuilds what’s affected. <code>{rixpress}</code> (and <code>ryxpress</code>) will try its best to show you to convert objects seamlessly from R to Python and vice-versa. If you try to load an object built inside a Python environment, <code>{rixpress}</code> will use <code>{reticulate}</code> (if you’ve added it to the list of R packages) to convert it to an equivalent R object. From a Python session, if you added the <code>rds2py</code> Python package, the same will happen, but converting an R object into the equivalent Python object (since Python doesn’t have a native data frame implementation, use <code>biocframe</code> to convert from R data frames into Python <em>bioc</em>frames, which come with a method to convert to <code>pandas</code> or <code>polars</code> data frames).</p>
<p>You can find the code for this example <a href="https://github.com/b-rodrigues/rixpress_demos/blob/master/rbc/">here</a>.</p>
<p>If you’re primary a Python user, I think that you could still find <code>{rixpress}</code> useful. Defining the pipeline as an R list shouldn’t be too much of an issue, and you can explore the pipeline and artefacts with the Python port, <code>ryxpress</code>. This Python port makes it easy to build the pipeline and load and explore artefacts from a Python session.</p>
<p>Another Python-related caveat is that while Nix’s package repository, <code>nixpkgs</code>, is vast, the Python ecosystem (PyPI) is famously heterogeneous. Not every Python package or specific version you might need is available directly in <code>nixpkgs</code>.</p>
<p>To solve this, it is possible to install <code>uv</code>, a modern and fast Python package manager, with Nix, and let <code>uv</code> handle the Python packages and Python interpreter, but let Nix handle everything else:</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rix</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">date =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"2025-10-20"</span>,</span>
<span id="cb6-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">r_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"rix"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"chronicler"</span>),</span>
<span id="cb6-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">system_pkgs =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"uv"</span>),</span>
<span id="cb6-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">project_path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>,</span>
<span id="cb6-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">overwrite =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>)</span></code></pre></div>
<p>This approach gives you the best of both worlds: you use <code>{rix}</code> to define the core, reproducible environment. This includes, critical system libraries (like GDAL or HDF5), and all your R and Julia dependencies. This part of your environment is bit-for-bit reproducible. Then, within this Nix-managed environment, you use standard <code>uv</code> commands (e.g., <code>uv pip install pandas</code>) to manage your Python packages. <code>uv</code> creates a <code>uv.lock</code> file that pins the exact versions and hashes of your Python dependencies, ensuring a reproducible Python package set.</p>
<p>While this hybrid model trades the full build-time determinism of a pure-Nix approach for Python packages, it offers immense flexibility and solves the issue of <code>nixpkgs</code> not mirrorring PyPI.</p>
<p>I think that the biggest hurdle for <code>{rix}</code> and <code>{rixpress}</code> adoption for Python data scientists is their love of Jupyter Notebooks.</p>
<p>By the way, it’s possible to use an IDE alongside Nix and <code>{rix}</code> and <code>{rixpress}</code>. I think I’ll make a video for that, though, but for those of you that prefer reading, <a href="https://docs.ropensci.org/rix/articles/e-configuring-ide.html">read this</a>.</p>



 ]]></description>
  <category>R</category>
  <category>Nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html</guid>
  <pubDate>Thu, 23 Oct 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Python needs its CRAN</title>
  <link>https://b-rodrigues.github.io/posts/2025-08-22-pypan.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/pkg_soyjak.png" style="width: 100%; height: auto;"> </a>
</p>
</div>
<p>How is it that in the year 2025 of our Lord installing a Python package is still such a gamble?</p>
<p>This post comes from someone that rarely uses Python, but consider the following:</p>
<ul>
<li>the rare times I need to use it, I’m often confronted to dependency hell (and if you think it’s a skill issue, hold that thought and keep reading);</li>
<li>I’m one of the maintainers of the R ecosystem for Nix, but also package some Python packages every once in a while for Nix.</li>
</ul>
<p>This last point is quite important, which I believe gives me a good perspective on the issue this blog post is about. When it comes to R packages, we know we can simply mirror CRAN and Bioconductor, as the upstream CRAN team already did a lot of curation efforts: we know packages work with each other. However, the same cannot be done for Python: the curation is on us.</p>
<p>If you use Python to analyse data (I’m sorry for you) you’ve probably hit this issue: you install one package that requires <code>numpy &lt; 2</code>, and another that requires <code>numpy &gt;= 2</code>. You’re <em>cooked</em>, as the youths say. The resolver can’t help you, because the requirements are literally incompatible. No one nor anything can help you. No amount of Rust-written package managers can help you. The problem is PyPI.</p>
<section id="cran-doesnt-tolerate-this-nonsense" class="level2">
<h2 class="anchored" data-anchor-id="cran-doesnt-tolerate-this-nonsense">CRAN doesn’t tolerate this nonsense</h2>
<p>In R, this situation simply doesn’t happen. Why? Because CRAN enforces a system where packages are tested not only in isolation, but against their reverse dependencies. If <code>{ggplot2}</code> or <code>{dplyr}</code> changes in a way that breaks others, CRAN catches it. Package authors get a warning, and if they don’t fix things (within 2 weeks!), their package gets archived, which means that when users try to install it with <code>install.packages("foo")</code>, it won’t work. Which means that if a package is on CRAN, <code>install.packages("foo")</code> will work. Not “works if you’re lucky.” Not “works if you pin the right versions.” It just works (of course, as long as the right system-level dependencies are available if you need to compile it, which isn’t an issue if you’re installing binaries though). Actually, you can’t even publish a package that has constraints on the version of its dependencies. Your package has to work with all packages on CRAN forever and ever. Honestly, quite impressive for something that’s not even a real programming language, right? (this is sarcastic btw)</p>
<p>And CRAN manages this consistency across <strong>27000 packages</strong>. PyPI is much bigger, granted, but I doubt that many more than 30k packages get actually used frequently. In fact, probably a couple thousand, maybe even a couple hundred do (especially for data analysis).</p>
</section>
<section id="pypi-is-a-warehouse-not-an-ecosystem" class="level2">
<h2 class="anchored" data-anchor-id="pypi-is-a-warehouse-not-an-ecosystem">PyPI is a warehouse, not an ecosystem</h2>
<p>PyPI doesn’t do this. It’s a dumping ground for tarballs and wheels. No global checks, no compatibility guarantees, no consistency across the ecosystem. If package A and package B declare mutually exclusive requirements, PyPI shrugs and hosts them both.</p>
<p>We then spend enormous effort building tools to try to deal with this mess: Conda, Poetry, Hatch, uv, pipx and Nix (well Nix was not specifically made for Python, but it can also be used to set up virtual environments). They’re all great tools, but they can’t solve the core problem: if the constraints themselves are impossible, no resolver can save you. At best, these tools give you a way to freeze a working mess before it collapses. Just pray to whichever deity you fancy that adding a new package down the line doesn’t explode your environment.</p>
<p>This is not an ecosystem. It’s chaos with good packaging tools.</p>
<p>But Nix does help a bit more; at least with Nix, you can patch a package’s <code>pyproject.toml</code> to try to relax imcompatible dependencies, like I did for <code>saiph</code>:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode nix code-with-copy"><code class="sourceCode nix"><span id="cb1-1">postPatch = <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span></span>
<span id="cb1-2"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">  # Remove these constraints</span></span>
<span id="cb1-3"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">  substituteInPlace pyproject.toml \</span></span>
<span id="cb1-4"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    --replace 'numpy = "^1"' 'numpy = "&gt;=1"' \</span></span>
<span id="cb1-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    --replace 'msgspec = "^0.18.5"' 'msgspec = "&gt;=0.18.5"'</span></span>
<span id="cb1-6"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>;</span></code></pre></div>
<p>This step relaxed the constraints directly in the <code>pyproject.toml</code>, but that might not be a good idea: these constraints might have been there for a good reason. Unit tests did pass though (more than 150 of them) so in this particular case I think I’m good. If PyPI was managed like CRAN, <code>saiph</code>’s authors would have had 2 weeks to make sure that <code>saiph</code> worked well with Numpy 2, which seems to be the case here. But patching packages is certainly not a solution for everything.</p>
</section>
<section id="the-scale-myth" class="level2">
<h2 class="anchored" data-anchor-id="the-scale-myth">The scale myth</h2>
<p>“But Python is too big and diverse for CRAN-style governance!” I hear you yell. This is simply false. CRAN manages 27000 packages across domains as varied as bioinformatics, finance, web scraping, geospatial analysis, and machine learning, and this is without counting old packages that have been archived through the years. The R ecosystem isn’t small or homogeneous. It is smaller than PyPI in absolute numbers, yes, but honestly, I doubt there are more data analytics packages on PyPI than on CRAN, and if older unmaintained Python packages would get removed, the number of PyPI packages would also be much smaller. If anyone has hard statistics on it, I’d be happy to read them.</p>
<p>The difference isn’t technical capacity or ecosystem size. It’s <strong>governance philosophy</strong>. CRAN chose consistency over permissiveness. PyPI chose the opposite.</p>
</section>
<section id="and-no-conda-forge-isnt-enough" class="level2">
<h2 class="anchored" data-anchor-id="and-no-conda-forge-isnt-enough">And no, conda-forge isn’t enough</h2>
<p>Conda-forge is curated in that its builds are consistent, compilers are pinned, migrations are coordinated. That’s great, and it proves Python packaging can work at scale.</p>
<p>But if package A wants <code>numpy &lt; 2</code> and package B wants <code>numpy &gt;= 2</code>, conda-forge will host them both, and you’re still stuck. There’s no enforcement mechanism that forces the ecosystem to resolve contradictions. CRAN has that. Conda-forge doesn’t.</p>
<p>Conda-forge is a step in the right direction, but a tighter governance is needed.</p>
</section>
<section id="what-python-actually-needs-pypan" class="level2">
<h2 class="anchored" data-anchor-id="what-python-actually-needs-pypan">What Python actually needs: PyPAN</h2>
<p>Python needs a curated layer on top of PyPI that enforces consistency. Call it PyPAN: the Python Package Archive Network.</p>
<p>Here’s what PyPAN would do:</p>
<ul>
<li>Mirror packages from PyPI, but only those that pass ecosystem-wide checks</li>
<li>Test every package against its reverse dependencies, not just itself</li>
<li>Coordinate migrations for major breaking changes (e.g.&nbsp;<code>numpy 2.0</code>)</li>
<li>Archive packages that refuse to adapt</li>
<li>Publish consistent, installable snapshots of the entire ecosystem</li>
</ul>
<p>In other words: CRAN, but for Python.</p>
<p>If CRAN can maintain consistency across 27’000 packages (by such a <a href="https://cran.r-project.org/CRAN_team.htm">small team</a> by the way), Python can too. The question isn’t whether it’s technically possible but whether the Python community is willing to prioritize ecosystem stability over individual package autonomy.</p>
</section>
<section id="why-developers-would-submit-to-pypan" class="level2">
<h2 class="anchored" data-anchor-id="why-developers-would-submit-to-pypan">Why developers would submit to PyPAN</h2>
<p>Why would a package author bother? Simple:</p>
<ul>
<li><strong>Visibility</strong>: users will prefer packages on PyPAN because they actually install and work</li>
<li><strong>Less support burden</strong>: fewer bug reports about broken installs or dependency hell</li>
<li><strong>Shared responsibility</strong>: migration effort spread across the ecosystem, not left to individual maintainers</li>
<li><strong>Credibility</strong>: “on PyPAN” becomes a mark of quality and stability — especially for scientific and industry projects</li>
</ul>
<p>If you don’t opt in, fine. But eventually, users will prefer packages that are part of the curated, consistent set. Just like people prefer CRAN packages in R and avoid installing from GitHub if possible.</p>
</section>
<section id="maybe-lets-start-small" class="level2">
<h2 class="anchored" data-anchor-id="maybe-lets-start-small">Maybe let’s start small</h2>
<p>CRAN’s model proves that ecosystem-wide consistency is achievable, and I’m of the opinion that it could be also achievable at at Python’s scale. Conda-forge proves that curated Python packaging works.</p>
<p>Until Python has something like PyPAN, nothing changes. Dependency hell will keep developers up at night.</p>
<p>But we could start small. PyPAN could begin by focusing on data science, analysis, and statistics packages - the core scientific Python ecosystem. This subset is:</p>
<ul>
<li><strong>More manageable</strong>: ~500-1000 packages (I made up this range, could be more could be less, point is, it’s not the 300000 PyPi packages) instead of the entire PyPI</li>
<li><strong>Highly interconnected</strong>: numpy, pandas, scikit-learn, matplotlib, scipy form a natural dependency graph</li>
<li><strong>Stability-focused</strong>: data scientists prioritize reproducible results over bleeding-edge features</li>
<li><strong>Community-minded</strong>: scientific Python already coordinates major migrations (Python 2→3, NumPy 2.0)</li>
<li><strong>Proven demand</strong>: these users already gravitate toward conda-forge for stability</li>
</ul>
<p>A PyPAN-DS (Data Science) could demonstrate the model works, build trust, and create momentum for broader adoption. Once people see that <code>pip install pandas</code> (or <code>uv</code> if you prefer) can work as reliably as <code>install.packages('dplyr')</code>, expanding to web frameworks and other domains becomes much easier to sell.</p>
<p>The scientific Python community has the cohesion, the need, and the precedent for this kind of coordination. They could be Python’s CRAN pilot program.</p>
<p>Soooo… who’s building this?</p>


</section>

 ]]></description>
  <category>R</category>
  <guid>https://b-rodrigues.github.io/posts/2025-08-22-pypan.html</guid>
  <pubDate>Fri, 22 Aug 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>You can outsource the grunt work to an LLM, not expertise</title>
  <link>https://b-rodrigues.github.io/posts/2025-07-03-llm_time.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/llm_nope_lmao.png" style="width: 100%; height: auto;"> </a>
</p>
</div>
<p>The more I use LLMs for programming, the more it seems to me that they can only be used successfully if you ask them to do things that you could do yourself.</p>
<p>This seems to be the case because:</p>
<ul>
<li>you know exactly what you want/need and thus can exactly describe it;</li>
<li>you know exactly if the LLM is actually delivering quality code or not;</li>
<li>you know exactly if something the LLM suggests that you hadn’t thought about actually makes sense;</li>
</ul>
<p>This reminds me of my consulting years, where it was quite easy to predict if a consulting project would be successful. If the client could do it themselves <em>if they had time</em>, the project would always be successful. They knew exactly what they needed and could describe it to us, and most importantly, there was a very tight feedback loop between our intermediary outputs and their review. But when we were brought in and clients didn’t even understand what their problem was (but thought they knew), this is where things were difficult.</p>
<p>It seems to me that as long as people cannot communicate their needs clearly, developers will keep their jobs.</p>
<p>Now, this doesn’t mean that you cannot do things outside of your expertise with LLMs, but you must then use the LLM to teach you enough (alongside more traditional methods), or you must do something so trivial and done a billion times before and low stakes enough that you can blindly trust the output.</p>
<p>I’ve used an LLM recently to write code to parse json and XML files, which is something I’ve done in the past and which I’m quite happy to likely never have to do myself again. The output was quite good, and only required minor correction before working. To help the LLM generate a correct output, I gave it one XML file as context.</p>
<p>Another thing I ask the LLM to do is to write code to get data from the Openalex api using the <code>{openalexR}</code> package. To help it, I gave it the package’s and api’s documentation. Here again, the code worked flawlessly, and again, this is something I <em>could</em> have done myself, so my prompt was quite precise and I knew I had to give the LLM <em>something</em> to ensure it generated valid code.</p>
<p>Btw, I’ve been using Claude Sonnet 4 and it works quite well for R. But I also like Gemini because of its very large context window.</p>



 ]]></description>
  <category>R</category>
  <guid>https://b-rodrigues.github.io/posts/2025-07-03-llm_time.html</guid>
  <pubDate>Thu, 03 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>ggplot2 4.0.0 is coming and why ultimately it’s on YOU to ensure your environments are reproducible</title>
  <link>https://b-rodrigues.github.io/posts/2025-06-21-ggplot4.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/midnight.jpg" style="width: 50%; height: auto;"> </a>
</p>
</div>
<p>It looks like a major update to <code>{ggplot2}</code> is coming (version 4.0.0), where Posit is switching the internals from S3 to S7. This will break many reverse dependencies of <code>{ggplot2}</code> (a reverse dependency is a package that depends on <code>{ggplot2}</code>), and so Posit is following the recommendation of the CRAN policies, which state that they should give a heads-up to devs of reverse dependencies and give them enough time to fix their packages. Posit even goes beyond that and is opening PRs to offer fixes themselves, which I think is really great.</p>
<p>However, this seems to be a bit trickier in the case of R packages hosted on Bioconductor: my understanding of Bioconductor is that they have two releases per year, and packages cannot be updated in between releases. Now I’m not entirely sure if that is exactly the case, or if some exceptions can be made and packages can perhaps be fixed in between releases. That being said, it seems like this upgrade will cause some issues, and there is apparently quite a heated discussion on Bioconductor’s community chat (which I don’t have access to).</p>
<p>Whatever is going to happen, and whatever is going on in this discussion, and whatever you think of Posit, CRAN, or Bioconductor, as an end-user, there are not a million things that you can do to make sure that upgrading to the latest <code>{ggplot2}</code> (or whichever packages) won’t break projects you’re currently working on:</p>
<ul>
<li>only use dependency-free packages like those from the <a href="https://www.tinyverse.org/">tinyverse</a> or even just base R</li>
<li>use something like <code>{renv}</code> or <code>{groundhog}</code> to snapshot package versions, or better yet, Nix using my <code>{rix}</code> package</li>
<li>just don’t care and hope for the best.</li>
</ul>
<p>Ultimately, it is on YOU to ensure that your projects are reproducible, and that you can work with stable environments. Relying on infrastructure or upstream developers you don’t control is not a valid strategy.</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-06-21-ggplot4.html</guid>
  <pubDate>Sat, 21 Jun 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Multi-language pipelines with rixpress</title>
  <link>https://b-rodrigues.github.io/posts/2025-05-13-test_rixpress.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/polyglot_dag.png" style="width: 50%; height: auto;"> </a>
</p>
</div>
<p>
If you want to watch a 2-Minute video introduction to <code>{rixpress}</code>, click the image below:
</p>
<p><a href="https://www.youtube.com/watch?v=a1eNG9TFZ_o" target="_blank" rel="noopener noreferrer"> <img src="https://raw.githubusercontent.com/b-rodrigues/rixpress/refs/heads/main/video_thumbnail.png" alt="Video Thumbnail" style="width:100%; max-width:560px; height:auto; display:block; margin:0 auto;"> </a></p>
<p>In <a href="https://brodrigues.co/posts/2024-08-28-nix_for_r_part_12.html">August last year</a> I tried to see how one could use Nix as a built automation tool for data science pipelines, and in March this year, I’ve started working on an R package that would make setting up such pipelines easy, which I already discussed in my <a href="https://brodrigues.co/posts/2025-03-20-announcing_rixpress.html">previous post</a>.</p>
<p>After some weeks of work, I think that <code>{rixpress}</code> is at stage where it can already be quite useful to a lot of people. <code>{rixpress}</code> helps you set up your projects as a pipeline of completely reproducible steps. <code>{rixpress}</code> is a sister package to <code>{rix}</code> and together they make true computational reproducibility easier to achieve. <code>{rix}</code> makes it easy to capture and rebuild the exact computational environment in which the code was executed, and <code>{rixpress}</code> helps you move away from script-based workflows that can be difficult to execute and may require manual intervention.</p>
<p>When I first introduced <code>{rixpress}</code>, it was essentially a proof of concept. It could manage some basic R and Python interplay, but it was clearly in its early stages. I’ve since then added some features that I think really show why using Nix as the underlying build engine is a good idea.</p>
<p>Just like for its sister package <code>{rix}</code>, I’ve taken the step to submit <code>{rixpress}</code> for peer review by rOpenSci. <code>{rix}</code> really benefitted from rOpenSci’s peer review and I believe that it’ll be the same for <code>{rixpress}</code>.</p>
<section id="current-capabilities-of-rixpress" class="level2">
<h2 class="anchored" data-anchor-id="current-capabilities-of-rixpress">Current Capabilities of {rixpress}</h2>
<p>Here are the features currently available in <code>{rixpress}</code>:</p>
<ul>
<li><p>A key motivation was to simplify building pipelines where different steps might require different language environments. With <code>{rixpress}</code>, this is a central feature:</p></li>
<li><p>Define steps in R (<code>rxp_r()</code>, <code>rxp_r_file()</code>) or Python (<code>rxp_py()</code>, <code>rxp_py_file()</code>).</p></li>
<li><p>Importantly, each step can be configured to run in its own Nix-defined environment (for example, use <code>nix_env = "my-python-env.nix"</code> for a Python step, or <code>nix_env = "my-r-env.nix"</code> for an R step). These environments can be generated using my other package, <code>{rix}</code>.</p></li>
<li><p>Pass data between R and Python steps. <code>{rixpress}</code> manages the serialization, using <code>reticulate</code> by default for R/Python object conversion, and also allows custom functions for other formats like JSON or model-specific files.</p></li>
<li><p>Build Quarto (or R Markdown) documents using <code>rxp_quarto()</code> (and <code>rxp_rmd()</code>). These documents can access any artifact (<code>rxp_read("my_artifact")</code>) from preceding steps, regardless of the language used to generate it. Quarto rendering can also occur within its own dedicated Nix environment.</p></li>
<li><p>Every step in a <code>{rixpress}</code> pipeline is treated as a Nix derivation. This means hermetic builds, sandboxed execution, and content-addressable caching, leading to a high degree of reproducibility (as expected with Nix).</p></li>
<li><p>As pipelines grow, visualization is helpful. <code>rxp_ggdag()</code> (using <code>{ggdag}</code>) and <code>rxp_visnetwork()</code> (using <code>{visNetwork}</code>) provide a visual overview of dependencies. <code>dag_for_ci()</code> exports the DAG as an <code>{igraph}</code> dot file format, which can then be used for text-based visualisation on CI.</p></li>
<li><p>For CI, <code>rxp_ga()</code> can generate a GitHub Actions workflow to run the pipeline on each push. This workflow includes caching of Nix store paths between runs (using <code>export_nix_archive()</code> and <code>import_nix_archive()</code>) to avoid unnecessary rebuilds.</p></li>
<li><p>There is ample documentation, and even a vignette detailling how to use <code>{cmdstanr}</code> within a <code>{rixpress}</code> pipeline. <code>{cmdstanr}</code> works in a specific way, by compiling Stan models to C++, and so this requires careful management of Stan model compilation and sampling within the Nix sandbox, demonstrating that complex tools can be integrated.</p></li>
<li><p>It is possible to retrieve outputs from previous pipeline executions. <code>{rixpress}</code> maintains timestamped build logs. Functions like <code>rxp_list_logs()</code>, <code>rxp_inspect(which_log = "...")</code>, and <code>rxp_read("derivation_name", which_log = "...")</code> allow you to access the history of your pipeline’s execution and retrieve specific artifacts.</p></li>
</ul>
</section>
<section id="an-invitation-for-feedback" class="level2">
<h2 class="anchored" data-anchor-id="an-invitation-for-feedback">An Invitation for Feedback</h2>
<p>Considerable effort has gone into making <code>{rixpress}</code> robust and useful. A collection of examples is available at the <a href="https://github.com/b-rodrigues/rixpress_demos">rixpress_demos GitHub repository</a> to illustrate various use cases (R-only, Python-only, R/Python, Quarto, <code>{cmdstanr}</code>, and an XGBoost example).</p>
<p>I’m now looking for feedback from users: * I encourage you to try it out. I recommend watching this <a href="https://youtu.be/IXKd5ySzzSU?si=D-AbU0JYdMP-iKvB">tutorial video</a> to get started quickly. * Install it, explore the examples, and perhaps apply it to one of your projects. * Any observations on what works well, what might be confusing, or any issues encountered would be helpful. * Your feedback would be very valuable. Please feel free to open an issue on the <a href="https://github.com/b-rodrigues/rixpress">{rixpress} GitHub repository</a> with bug reports, feature suggestions, or questions.</p>
</section>
<section id="why-use-rixpress-instead-of-targets" class="level2">
<h2 class="anchored" data-anchor-id="why-use-rixpress-instead-of-targets">Why use {rixpress} instead of {targets}?</h2>
<p><code>{targets}</code> is a fantastic package, and the main source of inspiration of <code>{rixpress}</code>. If you have no need for multilanguage pipelines, then running <code>{targets}</code> inside of a Nix environment, as described <a href="https://docs.ropensci.org/rix/articles/z-advanced-topic-reproducible-analytical-pipelines-with-nix.html">here</a> is perfectly valid. But I think that <code>{rixpress}</code> has its place if:</p>
<ul>
<li>you need to use multiple languages, as you don’t need adapt Python code to work with <code>{reticulate}</code>,</li>
<li>you’re already convinced by Nix and use <code>{rix}</code>,</li>
<li>want to use a simple pipeline-tool, with a smaller scope.</li>
</ul>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-05-13-test_rixpress.html</guid>
  <pubDate>Tue, 13 May 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Announcing rixpress</title>
  <link>https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/announcing_rixpress.png" style="width: 50%; height: auto;"> </a>
</p>
</div>
<p>As I’ve already discussed in <a href="https://docs.ropensci.org/rix/articles/z-advanced-topic-reproducible-analytical-pipelines-with-nix.html">this vignette of my {rix} package</a>, it is very easy to run a <code>{targets}</code> pipeline inside of a Nix environment for increased reproduciblity. The main drawback of <code>{targets}</code> though, is that it is not possible to compute one particular object in one particular environment, and another object in another environment. It is also not possible to compute a target using Python for instance, unless you use <code>{reticulate}</code>.</p>
<p>But we can go a step further: you see, Nix is a very versatile tool, and the Nix programming language is a domain-specific language made to package software. If you assume that, say, a statistical or machine learning model is just software, then why not use Nix to build it? This thought is what made me want to write <code>{rixpress}</code>.</p>
<section id="rixpress-a-package-to-define-reproducible-analytical-pipelines" class="level2">
<h2 class="anchored" data-anchor-id="rixpress-a-package-to-define-reproducible-analytical-pipelines">rixpress, a package to define reproducible analytical pipelines</h2>
<p>The Nix programming language is a domain specific language used to package and build software, and “software” can have a very broad definition. As I explored in <a href="../posts/2024-08-28-nix_for_r_part_12.html">this blog post</a>, Nix (the programming language) can be used to define a polyglot pipeline to build, for example, a Quarto report using R and Python. I have now built a package called <code>{rixpress}</code> which is heavily inspired by <code>{targets}</code> (if you are not familiar with <code>{targets}</code>, I introduce it at the end of this blog post) to generate such pipelines and build them using Nix. Below is a complete example which starts by using Python and the Polars library to load a dataset, then transforms it a bit, and converts the data to a Pandas dataframe then passes it to R (conversion is done via <code>reticulate::py_load_object()</code> under the hood, also why I had to convert the Polars dataframe to a Pandas dataframe) and finally compiles a Quarto document (you can find the code <a href="https://github.com/b-rodrigues/rixpress_pipeline_demo">here</a>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(rixpress)</span>
<span id="cb1-2"></span>
<span id="cb1-3">d0 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py_file</span>(</span>
<span id="cb1-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_pl,</span>
<span id="cb1-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'data/mtcars.csv'</span>,</span>
<span id="cb1-6">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">read_function =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"lambda x: polars.read_csv(x, separator='|')"</span>,</span>
<span id="cb1-7">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"py-env.nix"</span></span>
<span id="cb1-8">)</span>
<span id="cb1-9"></span>
<span id="cb1-10">d1 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb1-11">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># reticulate doesn't support polars DFs yet, so need to convert</span></span>
<span id="cb1-12">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># first to pandas DF</span></span>
<span id="cb1-13">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_pl_am,</span>
<span id="cb1-14">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mtcars_pl.filter(polars.col('am') == 1).to_pandas()"</span>,</span>
<span id="cb1-15">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"py-env.nix"</span></span>
<span id="cb1-16">)</span>
<span id="cb1-17"></span>
<span id="cb1-18">d2 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py2r</span>(</span>
<span id="cb1-19">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_am,</span>
<span id="cb1-20">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> mtcars_pl_am</span>
<span id="cb1-21">)</span>
<span id="cb1-22"></span>
<span id="cb1-23">d3 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(</span>
<span id="cb1-24">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_head,</span>
<span id="cb1-25">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">my_head</span>(mtcars_am),</span>
<span id="cb1-26">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">additional_files =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions.R"</span></span>
<span id="cb1-27">)</span>
<span id="cb1-28"></span>
<span id="cb1-29">d4 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(</span>
<span id="cb1-30">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_tail,</span>
<span id="cb1-31">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tail</span>(mtcars_head)</span>
<span id="cb1-32">)</span>
<span id="cb1-33"></span>
<span id="cb1-34">d5 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(</span>
<span id="cb1-35">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_mpg,</span>
<span id="cb1-36">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> dplyr<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">select</span>(mtcars_tail, mpg)</span>
<span id="cb1-37">)</span>
<span id="cb1-38"></span>
<span id="cb1-39">doc <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_quarto</span>(</span>
<span id="cb1-40">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> page,</span>
<span id="cb1-41">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">qmd_file =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"page.qmd"</span>,</span>
<span id="cb1-42">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">additional_files =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"content.qmd"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"images"</span>),</span>
<span id="cb1-43">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"quarto-env.nix"</span></span>
<span id="cb1-44">)</span>
<span id="cb1-45"></span>
<span id="cb1-46">rxp_list <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(d0, d1, d2, d3, d4, d5, doc)</span>
<span id="cb1-47"></span>
<span id="cb1-48"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rixpress</span>(rxp_list, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">project_path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span>)</span>
<span id="cb1-49"></span>
<span id="cb1-50"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot_dag</span>()</span></code></pre></div>
</div>
<p>Let’s go through this code:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1">d0 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py_file</span>(</span>
<span id="cb2-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_pl,</span>
<span id="cb2-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">path =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'data/mtcars.csv'</span>,</span>
<span id="cb2-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">read_function =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"lambda x: polars.read_csv(x, separator='|')"</span>,</span>
<span id="cb2-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"py-env.nix"</span></span>
<span id="cb2-6">)</span></code></pre></div>
</div>
<p><code>rxp_py_file()</code> uses Python to load a local file. In this case, it’s the <code>mtcars.csv</code> dataset under the <code>data/</code> folder. The read function must be a function of only one parameter, the path to the data, so I use an anonymous function wrapping <code>polars.read_csv</code> which allows me to set the separator to the unix pipe <code>|</code>. Also, this code is executed inside the environment defined by the <code>py-env.nix</code> file. This file can be generated by my other package, <code>{rix}</code> and lists the Python packages needed (you’ll find it in the repo).</p>
<p>Then:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1">d1 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py</span>(</span>
<span id="cb3-2">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># reticulate doesn't support polars DFs yet, so need to convert</span></span>
<span id="cb3-3">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># first to pandas DF</span></span>
<span id="cb3-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_pl_am,</span>
<span id="cb3-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">py_expr =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mtcars_pl.filter(polars.col('am') == 1).to_pandas()"</span>,</span>
<span id="cb3-6">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"py-env.nix"</span></span>
<span id="cb3-7">)</span></code></pre></div>
</div>
<p><code>rxp_py()</code> executes Python code, and saves the output into the <code>name</code> argument. In this case, I filter the Polars dataframe and convert it to a Pandas dataframe. This again happens inside the environment defined by <code>py-env.nix</code>, it’s a pure Python env, no <code>{reticulate}</code> needed at this stage.</p>
<p>Then:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1">d2 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_py2r</span>(</span>
<span id="cb4-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_am,</span>
<span id="cb4-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> mtcars_pl_am</span>
<span id="cb4-4">)</span></code></pre></div>
</div>
<p><code>rxp_py2r()</code> calls <code>reticulate::py_load_object()</code> to convert the Pandas dataframe to an R dataframe. We can now continue using it using R! You’ll notice that no <code>nix_env</code> argument is passed to this function. When no argument is provided to <code>nix_env</code>, the default environment, <code>default.nix</code> gets used. This one must always be present and in this case contains the required R packages for the pipeline.</p>
<p>Then:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1">d3 <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_r</span>(</span>
<span id="cb5-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> mtcars_head,</span>
<span id="cb5-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">expr =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">my_head</span>(mtcars_am),</span>
<span id="cb5-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">additional_files =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"functions.R"</span></span>
<span id="cb5-5">)</span></code></pre></div>
</div>
<p>This one uses an argument we don’t know yet, <code>additional_files</code>. It allows you to pass R scripts that define functions. In this case, <code>functions.R</code> contains the definition of <code>my_head()</code> which is used on <code>mtcars_am</code>.</p>
<p><code>d4</code> and <code>d5</code> are self-explanatory, so now let’s take a look at <code>rxp_quarto()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1">doc <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rxp_quarto</span>(</span>
<span id="cb6-2">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> page,</span>
<span id="cb6-3">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">qmd_file =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"page.qmd"</span>,</span>
<span id="cb6-4">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">additional_files =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"content.qmd"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"images"</span>),</span>
<span id="cb6-5">  <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">nix_env =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"quarto-env.nix"</span></span>
<span id="cb6-6">)</span></code></pre></div>
</div>
<p>This compiles the <code>page.qmd</code> document, which requires additional files: <code>content.qmd</code> which gets included into <code>page.qmd</code> and the <code>images/</code> folder, that contains images required to compile the document. This file is compiled using the <code>quarto-env.nix</code> environment.</p>
<p>Putting all these derivations into a list and passing it to <code>rixpress()</code> doesn’t build the pipeline just yet, but generates a <code>pipeline.nix</code> file which is the Nix expression that will build the output, in this case our Quarto document. You can also take a look at the DAG using <code>plot_dag()</code>:</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/rixpress_dag.png" width="100%">
</p>
</div>
<p>and it’s also possible to retrieve objects in an interactive sessions using <code>rxp_read()</code> (to read them) or <code>rxp_load()</code> (to load them in the global environment). When reading or loading Python objects, this will get converted using <code>{reticulate}</code> on the fly.</p>
<p>To build the pipeline, run <code>rxp_make()</code>. Subsequent runs don’t build everything, as intermediary outputs are cached in the <em>Nix store</em>. So if you change only the Quarto document, only this one derivation gets built anew. It is also possible to export and import the outputs using <code>export_nix_archive()</code> and <code>import_nix_archive()</code>, pretty useful for CI!</p>
</section>
<section id="caveats" class="level2">
<h2 class="anchored" data-anchor-id="caveats">Caveats</h2>
<p>This package is still in the prototype stage, so don’t use it for anything serious. There are still some things I need to work on, for now debugging a faulty pipeline is really hard because intermediary outputs are difficult to find if the pipeline wasn’t completely built.</p>
<p>Also, due to how Nix works, every computation happens in a completely isolated sandbox. This is why the <code>rxp_*()</code> functions have that <code>additional_files</code> argument, because in case something external is required, Nix needs to copy it over into the sandbox. This means also that functions that require Internet access to work will fail. But I was able to work around that for <code>rxp_file()</code>: so if a resource is online, the function that reads it should be able to get to it.</p>
<p>Now, let me introduce <code>{targets}</code>, my main source of inspiration for this package</p>
</section>
<section id="the-targets-package-my-source-of-inspiration-for-rixpress" class="level2">
<h2 class="anchored" data-anchor-id="the-targets-package-my-source-of-inspiration-for-rixpress">The targets package, my source of inspiration for rixpress</h2>
<p>I’m a huge fan of the <code>{targets}</code> package and think that it’s truly one of the best packages ever made. No other build/pipeline automation tool comes close in my opinion. Most of these tools require you to define your pipeline in another language (such as yaml) or force you to use some very specific syntax where you explicitely need to define the objects to compute, their inputs and outputs. But <code>{targets}</code> allows you to define your pipeline as a series of R calls:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># _targets.R file</span></span>
<span id="cb7-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(targets)</span>
<span id="cb7-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(tarchetypes)</span>
<span id="cb7-4"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_source</span>()</span>
<span id="cb7-5"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_option_set</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">packages =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"readr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ggplot2"</span>))</span>
<span id="cb7-6"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb7-7">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(file, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"data.csv"</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">format =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"file"</span>),</span>
<span id="cb7-8">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(data, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">get_data</span>(file)),</span>
<span id="cb7-9">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(model, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">fit_model</span>(data)),</span>
<span id="cb7-10">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(plot, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot_model</span>(model, data))</span>
<span id="cb7-11">)</span></code></pre></div>
</div>
<p>This may look foreign to many R users, but if you look closely, you’ll realise that most of this code is boilerplate:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># _targets.R file</span></span>
<span id="cb8-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(targets)</span>
<span id="cb8-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">library</span>(tarchetypes)</span>
<span id="cb8-4"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_source</span>()</span>
<span id="cb8-5"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_option_set</span>(<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">packages =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"readr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ggplot2"</span>))</span>
<span id="cb8-6"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">list</span>(</span>
<span id="cb8-7">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(....),</span>
<span id="cb8-8">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(....),</span>
<span id="cb8-9">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(....),</span>
<span id="cb8-10">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tar_target</span>(....)</span>
<span id="cb8-11">)</span></code></pre></div>
</div>
<p>and what matters is defined inside the <code>tar_target()</code> functions. Remove the boilerplate, and you end up with essentially correct R code, after a few adjustments:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1">file <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"data.csv"</span></span>
<span id="cb9-2">data <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">get_data</span>(file)</span>
<span id="cb9-3">model <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">fit_model</span>(data)</span>
<span id="cb9-4">plot <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot_model</span>(model, data)</span></code></pre></div>
</div>
<p>but why go through the trouble of using <code>{targets}</code>? Well, the biggest reason is that <code>{targets}</code> figures out the dependencies between the objects you want to compute, and caches them. So in the example above, if you only change the code of the <code>fit_model()</code> function, only <code>model</code> and <code>plot</code> are re-computed. But if you change <code>file</code> and point the path to an updated <code>data.csv</code> file, then everything gets computed anew. Watch the <a href="https://books.ropensci.org/targets/walkthrough.html">intro video</a> from the official walkthrough for a visual explanation: but trust me, <code>{targets}</code> is in this class of tools that make you wonder how you could possibly have gotten anything done before using it.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>I think that <code>{rixpress}</code> can become quite an useful package, so I will likely submit it for rOpenSci peer review in due time.</p>
<p>And thanks to <a href="https://grantmcdermott.com/">Grant McDermott</a> for suggesting the name “rixpress”!</p>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html</guid>
  <pubDate>Thu, 20 Mar 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Why we forked nixpkgs</title>
  <link>https://b-rodrigues.github.io/posts/2025-02-17-rstats-on-nix.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a> <img src="https://b-rodrigues.github.io/assets/img/fork.webp" style="width: 50%; height: auto;"> </a>
</p>
</div>
<section id="heres-why" class="level2">
<h2 class="anchored" data-anchor-id="heres-why">Here’s why</h2>
<p><code>nixpkgs</code> is a GitHub repository that contains tens of thousands of Nix expressions used by the Nix package manager to install software. By default, the nix package manager will pull expressions from <code>NixOS/nixpkgs</code>, but when using <code>{rix}</code> our fork <code>rstats-on-nix/nixpkgs</code> is used instead.</p>
<p>Because forks can sometimes be a bit controversial, we decided a blog post was in order.</p>
<p>First of all, let’s make something clear: this doesn’t mean that we don’t contribute to upstream anymore, quite the contrary. But Nix is first and foremost the package manager of a Linux distribution, NixOS, and as such, the way it does certain things only make sense in that context. For our needs, having a fork gives us more flexibility. Let me explain.</p>
<p>As you’ll know, if you’ve been using <code>{rix}</code> and thus Nix, it is possible to use a commit of the <code>nixpkgs</code> GitHub repository as the source for your packages. For example, the <code>6a9bda32519e710a0c0ab8ecfabe9307ab90ef0c</code> commit of <code>nixpkgs</code> will provide <code>{dplyr}</code> version 1.1.4 while this commit <code>407f8825b321617a38b86a4d9be11fd76d513da2</code> will provide version 1.0.7.</p>
<p>While it is technically possible for Nix to provide many versions of the same package (for example, you can install the latest Emacs by installing the <code>emacs</code> package, or Emacs 28 by installing <code>emacs28</code>) this ultimately depends on whether the maintainer wishes to do so, or whether it is practical. As you can imagine, with more than 20’000 CRAN and Bioconductor packages, that is not possible for us (by “us”, I mean the maintainers of the R ecosystem for Nix). So for a given <code>nixpkgs</code> commit, you won’t be able to <em>easily</em> install a specific version of <code>{dplyr}</code> that is not included in that particular <code>nixpkgs</code> commit. Instead, you can install it from source, and this is possible with <code>{rix}</code> by writing something like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rix</span>(..., <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">r_pkgs =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"dplyr@1.0.7"</span>, ...)</span></code></pre></div>
</div>
<p>but because this attempts to install the package from source, it can fail if that package needs Nix-specific fixes to work.</p>
<p>Also, it isn’t practical to update the whole of the R packages set on Nix every day: so while CRAN and Bioconductor get updates daily, the R packages set on Nix gets updated only around new releases of R. Again, this is a consequence of Nix being first and foremost the package manager of a Linux distribution with its own governance and way of doing things.</p>
<p>This is where the <code>rstats-on-nix</code> fork of <code>nixpkgs</code> is interesting: because it is a fork, we can afford to do things in a way that could not be possible or practical for upstream.</p>
<p>The first thing this fork allows us to do is offer a daily snapshot of CRAN. Every day, thanks to Github Actions, the R packages set gets updated, and the result commited to a dated branch. This has been going on since the 14th of December 2024 (see <a href="https://github.com/rstats-on-nix/nixpkgs/tree/2024-12-14">here</a>). So when you set a date as in <code>rix(date = "2024-12-14", ...)</code> this the fork that is going to get used. But this doesn’t mean that we recommend you use any date from the <code>rstats-on-nix/nixpkgs</code> fork: instead, each Monday, another action uses this fork and tries to build a set of popular packages on Linux and macOS, and only if this succeeds is the date added through a PR to the list of available dates on <code>{rix}</code>!</p>
<p>The reason this is done like this is to manage another <em>risk</em> of the upstream <code>nixpkgs</code>. As you know, <code>nixpkgs</code> is huge, and though the utmost care is taken by contributors and the PR review process is very strict, it can happen that updating packages breaks other packages. For example recently RStudio was in a broken state due to an issue in one its dependencies, <code>boost</code>. This is not the fault of anyone in particular: it’s just that packages get updated and packages that depend on them should get updated as well: but if that doesn’t happen quickly enough, the <code>nixpkgs</code> maintainer faces a conundrum. Either he or she doesn’t update the package because it breaks others, but not updating a package could be a security vulnerability, or he or she updates the package, but now others, perhaps less critical packages are broken and need to be fixed, either by their upstream developers, or by the <code>nixpkgs</code> maintainer of said packages. In the case of RStudio a fix was proposed and promptly merged, but if you wanted to install RStudio during the time it took to fix it, you would have faced an error message, which isn’t great if all you want is use Nix shells as development environments.</p>
<p>So for us, having a fork allows us to backport these fixes and so if you try to install RStudio using the latest available date, which is <code>"2025-02-10"</code>, it’s going to work, whereas if you tried to build it on that date using upstream <code>nixpkgs</code> you’d be facing an error!</p>
<p>We spent quite some time backporting fixes: we went back all the way to 2019. The way this works, is that we start by checking out a <code>nixpkgs</code> commit on selected dates, then we “update” the R packages set by using the Posit CRAN and Bioconductor daily snapshots. Then, we backport as many fixes as possible, and ensure that a selection of popular packages work on both x86-linux (which includes Windows, through WSL) and aarch64-darwin (the M-series of Macs). Then we commit everything to a dated branch of the <code>rstats-on-nix/nixpkgs</code> fork. You can check out all the available dates by running: <code>rix::available_dates()</code>. We’re pretty confindent that you should not face any issues when using Nix to build reproducible environments for R. However, should you face a problem, don’t hesitate to open an issue!</p>
<p>We have now packages and R versions working on Linux and macOS from March 2019 to now. See <a href="https://github.com/rstats-on-nix/daily_cran/blob/master/readme.md">this repository</a> that contains the scripts that allowed us to do it. Backporting fixes was especially important for Apple Silicon computers, as it took some time for this platform to work correctly on Nix. By backporting fixes, we can now provide olders versions of these packages for Apple Silicon as well!</p>
<p>Using this approach, our fork now contains many more versions of working R packages than upstream. <code>{rix}</code> will thus likely keep pointing towards our fork in the future, and not upstream anymore. This should provide a much better user experience. An issue with our fork though, is that by backporting fixes, we essentially create new Nix packages that are not included in upstream, and thus, these are not built by Hydra, Nix’s CI platform which builds binary packages. In practice this means that anyone using our fork will have to compile many packages from source. Now this is pretty bad, as building packages from source takes quite some time. But fear not, because thanks to <a href="https://www.cachix.org/">Cachix</a> we now also have a dedicated binary cache of packages that complements the default, public Nix cache! We provide instructions on how to use Cachix, it’s very easy, it’s just running 2 additional commands after installing Nix. Using Cachix speeds up the installation process of packages tremendously. I want to give my heartfelt thanks to <a href="https://www.cachix.org/about">Domen Kožar</a> for sponsoring the cache!</p>
<p>Another thing we do with our fork is run an action every day at midnight, that monitors the <em>health</em> of the R packages set. Of course, we don’t build every CRAN package, merely a handful, but these are among the most popular or the most <em>at-risk</em> of being in a broken state. See <a href="https://github.com/rstats-on-nix/monitor_health/actions">here</a>.</p>
</section>
<section id="also-theres-a-new-rix-release-on-cran" class="level2">
<h2 class="anchored" data-anchor-id="also-theres-a-new-rix-release-on-cran">Also, there’s a new rix release on CRAN</h2>
<p><code>{rix}</code> now handles remote packages that have remote dependencies (themselves with remote dependencies) much better thanks to code by <a href="https://github.com/mihem">Michael Heming</a>.</p>
<p>We also spent quite some time making <code>{rix}</code> work better with IDEs and have also documented that in a <a href="https://docs.ropensci.org/rix/articles/e-configuring-ide.html">new vignette</a>. The difference with previous releases of <code>{rix}</code>, is that now when a user supplies an IDE name to the <code>ide</code> argument of the <code>rix()</code> function, that IDE will get installed by Nix, which was previously not the case. This only really affects VS Code, as before, setting <code>ide = "code"</code> would only add the <code>{languageserver}</code> server package to the list of R packages to install. That was confusing, because if <code>ide = "rstudio"</code>, then RStudio would be installed. So we decided that if <code>ide = "some editor"</code>, then that editor should be installed by Nix. The vignette linked above explains in great detail how you can configure your editor to work with Nix shells.</p>
<p>If you decide to give <code>{rix}</code> a try, please let us know how it goes!</p>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-02-17-rstats-on-nix.html</guid>
  <pubDate>Mon, 17 Feb 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Using options() to inject a function’s internal variable for reproducible testing</title>
  <link>https://b-rodrigues.github.io/posts/2025-02-13-testthat.html</link>
  <description><![CDATA[ 




<p><em>No image this time</em></p>
<p>Imagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you want your function to always reproduce this intermediary variable, regardless of what you give it as inputs. This can be useful for testing, if computing this intermediate variable is costly.</p>
<p>In my <code>{rix}</code> package, the <code>rix()</code> function generates valid Nix expressions from R input and these Nix expressions can then be used to build reproducible development environments that include R, R packages, development libraries, and so on. If you want a 5-minute intro to <code>{rix}</code>, click <a href="https://www.youtube.com/watch?v=OOu6gjQ310c">here</a>.</p>
<p>Anyways, sometimes, computing these expressions can take some time, especially if the users wants to include remote dependencies that have themselves remote dependencies. <code>rix()</code> will try to look for suitable GitHub commits to pin all the packages for reproducibility purposes, and this can imply quite a lot of api calls. Now for my tests, I wanted to use an already generated <code>default.nix</code> file (which contains the generated Nix expression) but I didn’t want to have to recompute it every time I ran the test and I couldn’t simply use it as is for the test either. You see, that <code>default.nix</code> was in an intermediary state, before <code>rix()</code> is supposed to do some post-processing to it, which is what I actually want to test (I want to actually test the argument that makes <code>rix()</code> skip this post-processing step).</p>
<p>So suppose <code>rix()</code> looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1">rix <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span>(a,b,c){</span>
<span id="cb1-2">  ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># lots of code</span></span>
<span id="cb1-3">  ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># lots of code</span></span>
<span id="cb1-4">  default.nix_file <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># it's generated here</span></span>
<span id="cb1-5">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Then a bunch of things happen to it</span></span>
<span id="cb1-6">  out <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">f</span>(default.nix_file)</span>
<span id="cb1-7">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">writeLines</span>(out, path) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># this is what's written</span></span>
<span id="cb1-8">}</span></code></pre></div>
</div>
<p>Now what I want is to be able to “overwrite” the <code>default.nix_file</code> variable on line 4 when testing, to provide what I want. This way, I can call <code>rix()</code> with some “easy” parameters that make the computations up to that point very quick. My goal is essentially to test <code>f()</code> (line 6), which begs the question, why not write <code>f()</code> as a separate function and test it? This would be the best practice, however, I don’t really have such an <code>f()</code>, rather it’s a series of complicated steps that follow and rewriting everything to make it easily testable would just take too much time.</p>
<p>Instead, I opted for the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1">rix <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span>(a,b,c){</span>
<span id="cb2-2">  ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># lots of code</span></span>
<span id="cb2-3">  ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># lots of code</span></span>
<span id="cb2-4"></span>
<span id="cb2-5">  stub_default.nix <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">getOption</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"TESTTHAT_DEFAULT.NIX"</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">default =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">NULL</span>)</span>
<span id="cb2-6"></span>
<span id="cb2-7">  <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span>(<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">is.null</span>(stub_default.nix)){</span>
<span id="cb2-8">    default.nix_file <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">readLines</span>(stub_default.nix)</span>
<span id="cb2-9">  } <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> {</span>
<span id="cb2-10">    default.nix_file <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> ... <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># it's generated here if not being tested</span></span>
<span id="cb2-11">  }</span>
<span id="cb2-12">  out <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">f</span>(default.nix_file)</span>
<span id="cb2-13">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Then a bunch of things happen to it</span></span>
<span id="cb2-14">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">writeLines</span>(out, path) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># this is what's written</span></span>
<span id="cb2-15">}</span></code></pre></div>
</div>
<p>On line 5, I get the option <code>"TESTTHAT_DEFAULT.NIX"</code> and if it doesn’t exist, <code>stub_default.nix</code> will be set to <code>NULL</code>. So if it’s <code>NULL</code> it’s business as usual, if not, then that <code>default.nix</code> file dedicated for testing gets passed further down. In a sense, I injected the variable I needed in the spot I needed.</p>
<p>Then, my tests looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1">testthat<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">test_that</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"remove_duplicate_entries(), don't remove duplicates if skip"</span>, {</span>
<span id="cb3-2"></span>
<span id="cb3-3"></span>
<span id="cb3-4">  dups_entries_default.nix <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">paste0</span>(</span>
<span id="cb3-5">    testthat<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">test_path</span>(),</span>
<span id="cb3-6">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/testdata/default-nix_samples/dups-entries_default.nix"</span>)</span>
<span id="cb3-7"></span>
<span id="cb3-8">  tmpdir <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tempdir</span>()</span>
<span id="cb3-9"></span>
<span id="cb3-10">  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This copies the file I need in the right path</span></span>
<span id="cb3-11">  destination_file <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">file.path</span>(<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">tempdir</span>(), <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">basename</span>(dups_entries_default.nix))</span>
<span id="cb3-12">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">file.copy</span>(dups_entries_default.nix, destination_file, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">overwrite =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>)</span>
<span id="cb3-13"></span>
<span id="cb3-14">  <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">on.exit</span>(</span>
<span id="cb3-15">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">unlink</span>(tmpdir, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">recursive =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">force =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>),</span>
<span id="cb3-16">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">add =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span></span>
<span id="cb3-17">  )</span>
<span id="cb3-18"></span>
<span id="cb3-19">  removed_dups <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span>(destination_file) {</span>
<span id="cb3-20"></span>
<span id="cb3-21">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Set the option to the file path and clean the option afterwards</span></span>
<span id="cb3-22">    op <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">options</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"TESTTHAT_DEFAULT.NIX"</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">=</span> destination_file)</span>
<span id="cb3-23">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">on.exit</span>(<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">options</span>(op), <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">add =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>, <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">after =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">FALSE</span>)</span>
<span id="cb3-24"></span>
<span id="cb3-25">    out <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">rix</span>(</span>
<span id="cb3-26">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">date =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"2025-02-10"</span>,</span>
<span id="cb3-27">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">project_path =</span> tmpdir,</span>
<span id="cb3-28">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">overwrite =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>,</span>
<span id="cb3-29">      <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">skip_post_processing =</span> <span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">TRUE</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;- this is actually want I wanted to test</span></span>
<span id="cb3-30">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">file.path</span>(destination_file)</span>
<span id="cb3-31">  }</span>
<span id="cb3-32"></span>
<span id="cb3-33"></span>
<span id="cb3-34">  testthat<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">expect_snapshot_file</span>(</span>
<span id="cb3-35">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">path =</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">removed_dups</span>(destination_file),</span>
<span id="cb3-36">    <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">name =</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"skip-dups-entries_default.nix"</span>,</span>
<span id="cb3-37">  )</span>
<span id="cb3-38">})</span></code></pre></div>
</div>
<p>On line 22, I set the option and on line 23 I write code to remove that option once the test is done, to not mess up subsequent tests. This is a snapshot test, so now I can take a look at the resulting file, and indeed make sure that post-processing was skipped, as expected.</p>
<p>How would you have done this?</p>



 ]]></description>
  <category>R</category>
  <category>data-science</category>
  <guid>https://b-rodrigues.github.io/posts/2025-02-13-testthat.html</guid>
  <pubDate>Thu, 13 Feb 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>New year, new blog</title>
  <link>https://b-rodrigues.github.io/posts/2025-01-31-new_blog.html</link>
  <description><![CDATA[ 




<div style="text-align: center;">
<p>
<a href="https://www.youtube.com/watch?v=n__GJuqLb00"> <img src="https://b-rodrigues.github.io/assets/img/shadow.png" style="width: 40%; height: auto;"> </a>
</p>
</div>
<p>Happy new year! The blog has a new look! Well it’s not that different on the surface. But under the hood, it is quite different indeed!</p>
<p>My previous setup was: GitHub to host the code, on each push the build process would get started on Netlify and then it would be hosted there. The engine was Hugo.</p>
<p>This blog now still uses GitHub to host the code, but now also uses GitHub pages for hosting and the engine is <a href="https://quarto.org/docs/websites/website-blog.html">Quarto</a>. The blog also gets built on GitHub Actions inside of a Nix environment: so I just need to push and everything gets built! <a href="https://github.com/b-rodrigues/blog/blob/master/.github/workflows/build_publish.yaml">Here’s the workflow that achieves this</a>.</p>
<p>What’s really amazing with Nix, is that I can preview my blog locally using <em>exactly</em> the same environment as the one that will be used for building it on GitHub actions. So if it <em>works on my machine</em> it’s going to <em>work anywhere</em>.</p>
<p>You’ll notice that the last step uses the <code>rstats-on-nix/quarto-nix-actions/publish@main</code> action that is a fork of the <a href="https://github.com/quarto-dev/quarto-actions">quarto-dev/quarto-actions</a> actions that just makes them work inside of a Nix shell! This fork is hosted on the <code>rstats-on-nix</code> organization: I have a lot to say about this organization, but that’s for a future blog post!</p>
<p>Migrating the pages was a rather long process, as I needed to make sure everything was rendering correctly: because the folder structure of Quarto blogs is different than the structure of Hugo blogs, I had to update many paths. This was quite tedious and I didn’t want to use a script for this as I also wanted to take this opportunity to make some adjustments, such as centering images properly and correcting some typos if I saw some. It was also quite interesting to re-read some of my old blog posts.</p>
<p>One neat thing about Quarto is the possibility to use pre- and post-render scripts that can be written in R. I’m using one to correctly sort the blog posts in the main page, as for some reason they weren’t being sorted properly. <a href="https://github.com/b-rodrigues/blog/blob/master/order_posts.R">Here’s the post-render script in question.</a></p>
<p>Now I can go back to working on <a href="https://docs.ropensci.org/rix/">rix</a>.</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2025-01-31-new_blog.html</guid>
  <pubDate>Fri, 31 Jan 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 13 – {rix} is on CRAN!</title>
  <link>https://b-rodrigues.github.io/posts/2024-09-27-nix_part_13.html</link>
  <description><![CDATA[ 




<div data-align="center">
<p>
<a href="https://docs.ropensci.org/rix"> <img src="https://b-rodrigues.github.io/assets/img/rix-logo.png" width="100%" height="auto"> </a>
</p>
</div>
<p>
<em>Simplifies the creation of reproducible data science environments using the ‘Nix’ package manager, as described in Dolstra (2006) <a href="https://dspace.library.uu.nl/handle/1874/7540">&lt;ISBN 90-393-4130-3&gt;</a>. The included ‘rix()’ function generates a complete description of the environment as a ‘default.nix’ file, which can then be built using ‘Nix’. This results in project specific software environments with pinned versions of R, packages, linked system dependencies, and other tools. Additional helpers make it easy to run R code in ‘Nix’ software environments for testing and production.</em>
</p>
<p>
After 15 months of coding, 1364 commits, 143 closed issues, 175 closed PRs, an rOpenSci pre-review, an rOpenSci review, <code>{rix}</code> is finally on <a href="https://cran.r-project.org/web/packages/rix/index.html">CRAN</a>!
</p>
<p>
You can now install <code>{rix}</code> using good old <code>install.packages()</code>. Soon, <code>{rix}</code> will also be included into the <code>nixpkgs</code> collection of packages, meaning that you will be able to install <code>{rix}</code> with Nix.
</p>
<p>
Important sidenote: as it so happened, there is currently a bug in the released CRAN version that we thought we had solved, which we did, but only partially. When running <code>rix::rix()</code> two files should be generated: a <code>default.nix</code> and an <code>.Rprofile</code> for your project. It turns out that this file can be empty. If it is, run <code>rix::rix_init(rprofile_action = “overwrite”)</code> to generate a proper <code>.Rprofile</code>. This is important, especially on Mac or if you have a system-wide library of packages! We will submit a fix asap.
</p>
<p>
If you want to watch a 5-Minute video introduction:
</p>
<div data-align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/OOu6gjQ310c?si=tQ-s9ZgEBxak8k8G" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>
</div>
<p>
Btw, here is what <a href="https://github.com/boyter/scc">scc</a> has to say about the estimated cost of the project:
</p>
<p>
<code>scc –format=html-table –avg-wage 100000 .</code>
</p>
<div data-align="center">
<table class="table">
<colgroup>
<col width="15%">
<col width="11%">
<col width="11%">
<col width="11%">
<col width="13%">
<col width="10%">
<col width="16%">
<col width="11%">
</colgroup>
<thead>
<tr class="header">
<th>
<strong>Language</strong>
</th>
<th align="right">
<strong>Files</strong>
</th>
<th align="right">
<strong>Lines</strong>
</th>
<th align="right">
<strong>Blank</strong>
</th>
<th align="right">
<strong>Comment</strong>
</th>
<th align="right">
<strong>Code</strong>
</th>
<th align="right">
<strong>Complexity</strong>
</th>
<th align="right">
<strong>Bytes</strong>
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
YAML
</td>
<td align="right">
61
</td>
<td align="right">
2798
</td>
<td align="right">
320
</td>
<td align="right">
174
</td>
<td align="right">
2304
</td>
<td align="right">
0
</td>
<td align="right">
69187
</td>
</tr>
<tr class="even">
<td>
R
</td>
<td align="right">
33
</td>
<td align="right">
4515
</td>
<td align="right">
483
</td>
<td align="right">
1225
</td>
<td align="right">
2807
</td>
<td align="right">
389
</td>
<td align="right">
153288
</td>
</tr>
<tr class="odd">
<td>
Nix
</td>
<td align="right">
10
</td>
<td align="right">
781
</td>
<td align="right">
95
</td>
<td align="right">
0
</td>
<td align="right">
686
</td>
<td align="right">
32
</td>
<td align="right">
18644
</td>
</tr>
<tr class="even">
<td>
Markdown
</td>
<td align="right">
5
</td>
<td align="right">
1371
</td>
<td align="right">
339
</td>
<td align="right">
0
</td>
<td align="right">
1032
</td>
<td align="right">
0
</td>
<td align="right">
63758
</td>
</tr>
<tr class="odd">
<td>
JSON
</td>
<td align="right">
1
</td>
<td align="right">
147
</td>
<td align="right">
0
</td>
<td align="right">
0
</td>
<td align="right">
147
</td>
<td align="right">
0
</td>
<td align="right">
4637
</td>
</tr>
<tr class="even">
<td>
Plain Text
</td>
<td align="right">
1
</td>
<td align="right">
41
</td>
<td align="right">
0
</td>
<td align="right">
0
</td>
<td align="right">
41
</td>
<td align="right">
0
</td>
<td align="right">
2269
</td>
</tr>
<tr class="odd">
<td>
<strong>Total</strong>
</td>
<td align="right">
<strong>111</strong>
</td>
<td align="right">
<strong>9653</strong>
</td>
<td align="right">
<strong>1237</strong>
</td>
<td align="right">
<strong>1399</strong>
</td>
<td align="right">
<strong>7017</strong>
</td>
<td align="right">
<strong>421</strong>
</td>
<td align="right">
<strong>311783</strong>
</td>
</tr>
</tbody>
</table>
</div>
<p>
Estimated Cost to Develop (organic) $371,264 - Estimated Schedule Effort (organic) 7.59 months - Estimated People Required (organic) 2.45
</p>
<p>
Don’t hesitate to give <code>{rix}</code> a try and let us know how it goes!
</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2024-09-27-nix_part_13.html</guid>
  <pubDate>Fri, 27 Sep 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 12 – Nix as a polyglot build automation tool for data science</title>
  <link>https://b-rodrigues.github.io/posts/2024-08-28-nix_for_r_part_12.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/guess_we_doin_pdfs.png" width="60%">
</p>
</div>
<p>
Nix is not only a package manager, but also a build automation tool, and you can use it to build polyglot data science pipelines in a completely reproducible way.
</p>
<p>
For example, suppose that you need to mix Python, R and maybe some others tools for a project (by the way, some believe this will become the norm in the coming years, use your favourite search engine to look for “polyglot data science” and you’ll see), and suppose that you want to define your project as a nice reproducible pipeline, and not simply a series of scripts. What are the options available to you?
</p>
<p>
One option would be to use the <code>{targets}</code> package for R, which allows you to do lay out your project as pipeline. But as amazing as <code>{targets}</code> is, it only works with R. If you also need Python, you would then need to also use the <code>{reticulate}</code> package to interface with it. But what do you do if you need some other command line tools? Well, you could wrap them in an R function using <code>system()</code> or <code>system2()</code>. But what if you need yet another language, like Julia? There might be a way to call Julia from R, but as you see, the more diverse tools you need, the more complex it gets. And it doesn’t really matter if you switch from <code>{targets}</code> to another such package that exists for, say, Python, you would always need to write wrappers or use packages that allow you to call the other programming languages that you need.
</p>
<p>
Another possibility is to use good old <code>make</code>. <code>make</code> is a tool from the GNU project that allows you to define <em>targets</em>, which would be the outputs of a script or call to some cli tool by writing so-called <code>Makefiles</code>. For an example of a <code>Makefile</code> in research, take a look at <a href="https://github.com/grantmcdermott/skeptic-priors/blob/master/Makefile">this one</a> from a <a href="https://link.springer.com/article/10.1007/s10584-021-03089-x">paper</a> by <a href="https://mastodon.social/@gmcd">Grant McDermott</a>. You can use <code>make</code> as a to orchestrate several programming languages or cli tools, but you will need to write code to pass data from one script to the other. <code>{targets}</code> deals with that transparently by serialising all the targets’ outputs using <code>saveRDS()</code> but this only works because only R is supported. But if you’re trying to make R, Python, and whatever else work together, you will need to deal with this manually and find a common interface to pass data around.
</p>
<p>
Despite this, using <code>make</code>, or some other tool on top of the required programming languages (and not tied to either one), is likely the best solution and it turns out that Nix can be used just like that! But why use Nix and not <code>make</code> then? Well, using Nix guarantees that whatever you produce will be completely reproducible. With <code>make</code>, you would need to either run it inside a Docker image or… inside a development environment built with Nix! I did something similar in <a href="../posts/2023-07-19-nix_for_r_part2.html">this blog post</a> where I ran a <code>{targets}</code> pipeline inside a Nix environment to make the analysis reproducible.
</p>
<p>
But if I’m already defining a reproducible development environment using Nix, why not go all the way and build a complete project using Nix? After all, Nix allows you to package <em>software</em> and what is <em>software</em> but 0’s and 1’s? And what is a trained model, a paper or report in the PDF format, predictions exported into a CSV file, etc, if not 0’s and 1’s?
</p>
<p>
Just like with any other build automation tool, Nix will only rebuild the project if something changes, and will only rebuild the parts that need to be rebuilt. So if you change a file somewhere, only whatever depends on this file will get rebuilt, just like with <code>{targets}</code>, or <code>make</code>.
</p>
<p>
In the <a href="https://github.com/b-rodrigues/nixbat/tree/master">following repository</a> you can find an example of this.
</p>
<p>
This is a very simple project: two functions are defined in the <code>python_functions.py</code> script. These functions are nothing special, and could be used interactively. One function reads a <code>.csv</code> file from the Internet and returns it, the other does some basic cleaning. Here are these two functions included in the <code>python_functions.py</code> file:
</p>
<pre><code>from pandas import read_csv

def download_iris(iris_csv_url):
    # Read the CSV file
    df = read_csv(iris_csv_url)

    return df

def process_iris(iris_csv_path):
    # Read the CSV file
    df = read_csv(iris_csv_path)

    # Replace the species numbers with their corresponding names
    species_mapping = {0: "setosa", 1: "virginica", 2: "versicolor"}
    df['species'] = df['species'].replace(species_mapping)

    return df</code></pre>
<p>
Then, I want to use <code>{ggplot2}</code> to plot this data. You will notice the lack of R script in the repo. I did this on purpose, because I wanted to show how you could directly write R code inside of a Nix expression. But in practice, it is better to have Python code in a Python script, R code in an R script, and then use Nix to orchestrate the whole thing. But I just wanted to show you that you could, if you wanted to, have a completely self-contained Nix expression that encapsulates the business logic as well.
</p>
<p>
There’s also a <code>.Qmd</code> file: this is the file that will get compiled into a PDF document, and is the output of the whole project. It could be anything else! As I stated above, this is just 0’s and 1’s so it could very well be some other output, it doesn’t really matter.
</p>
<p>
Let’s now take a look at the <code>default.nix</code> that builds the whole thing. Let’s start by the top-level definitions:
</p>
<pre><code>let
  pkgs =
    import
      (fetchTarball "https://github.com/NixOS/nixpkgs/archive/27285241da3bb285155d549a11192e9fdc3a0d04.tar.gz")
      { };

  tex = (
    pkgs.texlive.combine {
      inherit (pkgs.texlive) scheme-small;
    }
  );

  # Because building happens in sandbox that cannot connect to the internet
  # we need to download assets beforehand
  iris_path = pkgs.fetchurl {
    url = "https://raw.githubusercontent.com/b-rodrigues/nixbat/7c319bcdbe15e7f7182e7685b8de176a40d0bde9/iris.csv";
    hash = "sha256-2H6THCXKxIt4yxnDDY+AZRmbxqs7FndCp4MqaAR1Cpw=";
  };

  # Common python dependencies to use in my intermediary inputs
  pythonEnv = pkgs.python312.withPackages (ps: with ps; [ pandas ]);

  # Common python sources
  python_src = pkgs.lib.fileset.toSource {
    root = ./.;
    fileset = ./python_functions.py;
  };</code></pre>
<p>
Some variables are defined there:
</p>
<ul>
<li>
<code>pkgs</code>: this is the set of Nix packages to be used. All the dependencies of the project will get built using the Nix expressions available in the <code>nixpkgs</code> Github repository at a specific commit. This ensures that the output of this expression will always be exactly the same.
</li>
<li>
<code>tex</code>: defines the set of LaTeX packages I need to compile the PDF.
</li>
<li>
<code>iris_path</code>: the Python function I use to load the data takes a path, or url, to read the iris dataset. Because building a derivation happens in a sandbox, I need to download assets beforehand. This is what the <code>fetchurl</code> function does. I can then refer to the file path using <code>${iris_path}</code> later on.
</li>
<li>
<code>pythonEnv</code>: This lists the dependencies I will need to run my Python functions.
</li>
<li>
<code>pythonSrc</code>: Defines the path to the <code>python_functions.py</code> file.
</li>
</ul>
<p>
Then, I want to call each of my functions separately, and I want them to produce a single output. So for this, I now build a derivation, one per output. I start with the first one:
</p>
<pre><code>downloadCsv = pkgs.stdenv.mkDerivation {
  name = "download-csv";
  buildInputs =  [ pythonEnv ];
  src = pythonSrc;
  buildPhase = ''
      python -c "
import pandas as pd
from python_functions import download_iris

iris_raw = download_iris('${iris_path}')

iris_raw.to_csv('iris_raw.csv', index=False)
      "
    '';
  installPhase = ''
    mkdir -p $out
    cp iris_raw.csv $out/
  '';
  };</code></pre>
<p>
At first sight, there might seem that a lot is going on, but let’s take a closer look:
</p>
<ul>
<li>
first I give it a name: <code>name = “download-csv”</code>
</li>
<li>
second, I list its dependencies in <code>buildInputs</code>. This is what’s required to build the target!
</li>
<li>
then, I provide the source, in this case the <code>python_functions.py</code> file
</li>
</ul>
<p>
Then, I need to run the code, and this is what happens in the <code>buildPhase</code>. This is exactly the code you would write if you were using a script to glue your functions together. See how I use <code>${iris_path}</code> to refer to the path to the file defined above. Finally, in the <code>installPhase</code> I copy the <code>.csv</code> file to <code>$out/</code>, which essentially copies the file into the Nix store, making it available for the next derivations.
</p>
<p>
In the next derivation, I now use the second Python function to clean the data:
</p>
<pre><code>cleanCsv = pkgs.stdenv.mkDerivation {
    name = "clean-csv";
    buildInputs =  [ pythonEnv ];
    src = pythonSrc;
    buildPhase = ''
      python -c "
import pandas as pd
from python_functions import process_iris

iris = process_iris('${downloadCsv}/iris_raw.csv')

iris.to_csv('iris.csv', index=False)
      "
    '';
    installPhase = ''
      mkdir -p $out
      cp iris.csv $out/
    '';
  };</code></pre>
<p>
This is not very different than what I did before. Just notice how I refer to the output of the first derivation: <code>${downloadCsv}/iris_raw.csv</code>.
</p>
<p>
Now comes the last intermediary derivation, the one that uses R to create a plot:
</p>
<pre><code>generatePlot = pkgs.stdenv.mkDerivation {
    name = "generate-plot";
    buildInputs = with pkgs; [
      R
      rPackages.ggplot2
      rPackages.janitor
    ];
    dontUnpack = true;
    buildPhase = ''
            Rscript -e "

      library(ggplot2)
      library(janitor)

      iris &lt;- read.csv('${cleanCsv}/iris.csv') |&gt;
        clean_names() |&gt;
        transform(species = as.character(species))

      p &lt;- ggplot(iris,
                  aes(x = sepal_length, y = sepal_width, color = species)) +
          geom_point(size = 3) +
          labs(title = 'Sepal Length vs Sepal Width',
               x = 'Sepal Length',
               y = 'Sepal Width') +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5))


      ggsave('plot.png', plot = p, width = 6, height = 4, dpi = 300)

      "
    '';
    installPhase = ''
      mkdir -p $out
      cp plot.png $out/
    '';
  };</code></pre>
<p>
As I said above, to make this better, it would need to be a function defined in its own R script, as this way there’s a nice separation of concerns. On one hand, there’s the business logic in Python and R scripts, and on the other there’s the orchestration in Nix. Putting R code in the Nix expression makes this less flexible, but I wanted to show you that this is also a possibility!
</p>
<p>
Now comes the last part of the Nix expression, the actual thing I want to build, a PDF that uses the generated plot as an input:
</p>
<pre><code>in
# Derivation to generate the PDF report from Markdown
pkgs.stdenv.mkDerivation {
  name = "generate-report";
  buildInputs = [
    pkgs.quarto
    tex
  ];
  src = pkgs.lib.fileset.toSource {
        root = ./.;
        # Only include report.Qmd in the source
        fileset = ./report.Qmd;
  };
  buildPhase = ''

    cp ${generatePlot}/plot.png .

    # Deno needs to add stuff to $HOME/.cache
    # so we give it a home to do this
    mkdir home
    export HOME=$PWD/home
    quarto render report.Qmd --to pdf

  '';

  installPhase = ''
    mkdir -p $out
    cp report.pdf $out/
  '';
}</code></pre>
<p>
Notice the dependencies of this derivation: <code>quarto</code> and <code>tex</code> (<code>tex</code> is the variable I defined right at the beginning that lists LaTeX packages). I then need to specify <code>report.Qmd</code> as the source of this derivation, and copy the plot generated before in R into the working/build directory. There’s also a idiosyncrasy where a dependency of Quarto, Deno, needs to have a directory to save some stuff in it. Nix being Nix, we need to manually define such a home directory for reproducibility purposes. If it would be using my <code>home/</code> directory on my machine, this wouldn’t be reproducible! We finish the <code>buildPhase</code> by rendering the document, and then <em>install</em> it into <code>$out/</code>. To build this project, you need to have Nix installed and then type <code>nix-build</code>, or alternatively, <code>nix-build -Q</code> which hides all the output of the build phases (so you don’t see any warnings or messages thrown by either Python or R).
</p>
<p>
This will build the PDF, which you can then find in the Nix store. You’ll notice a file called <code>result</code> appear next to all your other files from the project. In a terminal, call <code>readlink result</code> and this will show you the path to the generated PDF, which you can now read!
</p>
<p>
In conclusion, I think that this is a really useful way to orchestrate code written in different programming languages, but I would not use this for monolingual projects. For R, I’ll keep using <code>{targets}</code> together with a Nix shell to ensure reproducibility. Also, to really benefit from this, your code needs, ideally, to be written as a series of functions, each outputting a single object. Instead, if you write a script to orchestrate the whole thing in R or Python, and then put a Nix expression on top of it, I’m not sure it’s really worth it. Might as well just use a Nix shell then and execute your scripts in it.
</p>
<p>
Also, let me state that this is my first attempt at using Nix for such a purpose, and there might be a better/more elegant way of doing it, so if you have any input, don’t hesitate!
</p>
<p>
<em>Thanks to <a href="https://discourse.nixos.org/t/derivation-gets-always-rebuilt/51246/3">the amazing Nix community for helping out!</a></em>
</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2024-08-28-nix_for_r_part_12.html</guid>
  <pubDate>Wed, 28 Aug 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 11 – build and cache binaries with Github Actions and Cachix</title>
  <link>https://b-rodrigues.github.io/posts/2024-04-04-nix_for_r_part_11.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/own_cache.jpg" width="60%">
</p>
</div>
<section id="intro" class="level2">
<h2 class="anchored" data-anchor-id="intro">
Intro
</h2>
<p>
I have this package on CRAN called <code>{chronicler}</code> and last month I got an email from CRAN telling me that building the package was failing, and I had two weeks to fix it.
</p>
<p>
I immediately thought that some dependency that my package depends on got updated, and somehow broke something. But when I checked the results of the build, I was surprised, to say the least:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/chronicler_check_results.png" width="80%">
</p>
</div>
<p>
How come my package was only failing on Fedora? Now that was really weird. There was no way this was right. Also, I couldn’t reproduce this bug on my local machine… but I could reproduce it on Github Actions, on Ubuntu (but it was ok on CRAN’s Debian which is really close to Ubuntu!), but couldn’t reproduce it either on Windows! What was going on? So I started digging, and my first idea was to look at the list of packages that got released on CRAN on that day (March 12th 2024) or just before, and saw something that caught my eye: a new version of <code>{tidyselect}</code> had just been released and even though my package doesn’t directly depend on it, I knew that this package was likely a dependency of some direct dependency of <code>{chronicler}</code>. So I looked into the release notes, and there it was:
</p>
<pre><code>* `eval_select()` out-of-bounds errors now use the verb "select" rather than
  "subset" in the error message for consistency with `dplyr::select()` (#271).</code></pre>
<p>
I knew this was what I was looking for, because the unit test that was failing to pass was a test that should error because <code>dplyr::select()</code> was being used on a column that didn’t exist. So the success of that test was defined as <em>finding the following error message in the log</em>, which contained the word <em>subset</em> but now it should be <em>select</em>.
</p>
<p>
But why was this failing only on Fedora on CRAN and on Ubuntu on Github Actions (but ok on Debian on CRAN)? And why couldn’t I reproduce the bug on my OpenSuse Linux computer, even though I was building a bleeding edge development environment using Nix?
</p>
<p>
And then it hit me like my older brother used to.
</p>
<p>
When building packages, CRAN doesn’t seem to use pre-compiled binaries on Fedora, so packages get built from source. This means that it takes longer to test on Fedora, as packages have to be built from source, but it also means that only the very latest releases of packages get used. On other platforms, pre-compiled binaries get used if available, and because <code>{tidyselect}</code> had just come out that very day, older binaries of <code>{tidyselect}</code> were being used on these platforms, but not on Fedora. And because these older binaries didn’t include this change, the unit test was still passing successfully on there.
</p>
<p>
On Github Actions, code coverage was computed using <code>covr::codecov()</code> which installs the package in a temporary directory and seems to pull its dependencies directly from CRAN. Because CRAN doesn’t offer Linux binaries packages got compiled from source, hence why the test was failing there, as the very latest version of <code>{tidyselect}</code> was being used (btw, use Dirk Eddelbuettel’s <a href="https://github.com/eddelbuettel/r2u">r2u</a> if you binaries for Ubuntu).
</p>
<p>
And on my local machine, even though I was using the latest commit of <code>nixpkgs</code> to have the most bleeding edge packages for my environment, I had forgotten that the R packages on <code>nixpkgs</code> always lag behind the CRAN releases.
</p>
<p>
This is because R packages on <code>nixpkgs</code> tend to get updated alongside a new release of R, and the reason is to ensure a certain level of quality. You see, the vast majority of CRAN (and Bioconductor) packages are made available through <code>nixpkgs</code> in a fully automated way. But some packages do require some manual intervention to work on Nix. And we only know this if we try to build these packages, but building packages requires quite a lot of resources. I go into more detail <a href="../posts/2024-02-29-nix_for_r_part_10.html">here</a>, but in summary we can’t build CRAN packages every single day to see if everything works well, so we only rebuild the whole tree whenever there’s a new release of R. Packages get built on a CI infrastructure called <em>Hydra</em>, and then get cached on <code>cache.nixos.org</code> so whenever someone wants to install a package, a pre-built binary gets pulled from the cache instead of getting installed from source. For packages that don’t need compiling this is not that big of a time save, but for packages that do need to get compiled it is huge. Depending on which packages you want to install, if you had to build everything from source, it could potentially take hours, but if you can install pre-built binaries it’s just a matter of how quick your internet connection is.
</p>
<p>
Anyways, I went back to my fork of <code>nixpkgs</code> and updated the expression defining the CRAN packages myself and installed the latest versions of packages from my fork.
</p>
<p>
Before the update, this was the error message I was testing against:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/cant_subset.png" width="80%">
</p>
</div>
<p>
and this was on version 1.2.0 of <code>{tidyselect}</code>:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/tidyselect_120.png" width="50%">
</p>
</div>
<p>
but after the update, this was the error message:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/cant_select.png" width="80%">
</p>
</div>
<p>
on version 1.2.1 of <code>{tidyselect}</code>:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/tidyselect_121.png" width="50%">
</p>
</div>
<p>
so I found the issue, and updated my unit testing accordingly, and pushed the update to CRAN. All is well that ends well, but… this made me think. I needed to have an easy way to have bleeding edge packages on hand from Nix at all moments, and so I started working on it.
</p>
</section>
<section id="github-actions-to-the-rescue" class="level2">
<h2 class="anchored" data-anchor-id="github-actions-to-the-rescue">
Github Actions to the rescue
</h2>
<p>
As described in my <a href="../posts/2024-02-29-nix_for_r_part_10.html">previous blog post</a> updating the Nix expressions defining the R packages on <code>nixpkgs</code> involves running an R script that generates a Nix expression which then builds the R packages when needed. So what I did was create a Github actions that would run this R script every 6 hours, and push the changes to a branch of my <code>nixpkgs</code> fork. This way, I would always have the possibility to use this branch if I needed bleeding edge packages. Because this can be of interest to others, <a href="https://github.com/philipp-baumann">Philipp Baumann</a> started a Github organisation hosting this fork of <code>nixpkgs</code> that gets updated daily which you can find <a href="https://github.com/rstats-on-nix">here</a>. Because this action needs to run several times a day, it should be on a schedule, but actions on a schedule can only run from master/main. But that’s not what we wanted, so instead, we are using another action, on another repository, that pushes a random file to the target repository to get the action going. You can find this repository <a href="https://github.com/b-rodrigues/trigger-r-updates">here</a> with complete instructions. So to summarise:
</p>
<ul>
<li>
An action on schedule runs from b-rodrigues/trigger-r-updates and pushes a file to rstats-on-nix/nixpkgs on the <code>r-daily-source</code> branch
</li>
<li>
This triggers an action that updates all of <code>nixpkgs</code>, including R packages, and pushes all the updates to the <code>r-daily</code> branch (you can find it <a href="https://github.com/rstats-on-nix/nixpkgs/blob/r-daily-source/.github/workflows/r-daily.yml">here</a>)
</li>
<li>
We can now use the <code>r-daily</code> branch to get bleeding edge R packages on Nix!
</li>
</ul>
<p>
This happens without any form of testing though, so packages could be in a broken state (hey, that’s the definition of bleeding edge, after all!), and also, if anyone would like to use this fork to build a development environment, they’d have to rebuild a lot of packages from source. Again, this is because these packages are defined in a fork of <code>nixpkgs</code> and they don’t get built on Hydra to populate the public cache that Nix uses by default. So while this fork is interesting because it provides bleeding edges packages, using it on a day-to-day basis can be quite tedious.
</p>
<p>
And this is where <a href="https://www.cachix.org/">Cachix</a> comes into play.
</p>
</section>
<section id="setting-up-your-own-binary-cache-on-cachix" class="level2">
<h2 class="anchored" data-anchor-id="setting-up-your-own-binary-cache-on-cachix">
Setting up your own binary cache on Cachix
</h2>
<p>
<a href="https://www.cachix.org/">Cachix</a> is an amazing tool that makes it incredibly easy to set up your own cache. Simply build the packages once, and push the binaries to the cache. As long as these packages don’t get updated, they’ll get pulled from the cache instead of getting rebuilt.
</p>
<p>
So now, here is what I do with my packages: I define a <code>default.nix</code> file that defines a development environment that uses my fork of <code>nixpkgs</code> as the source for packages. For example, <a href="https://github.com/b-rodrigues/rix/blob/master/default.nix">here</a> is this file that defines the environment for my <code>{rix}</code> package. I can use this environment to work on my package, and make sure that anyone else that wants to contribute, contributes using the same environment. As you can see on line 2, the <code>rstats-on-nix</code> bleeding edge fork gets used:
</p>
<pre><code> pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/refs/heads/r-daily.tar.gz") {};</code></pre>
<p>
Then, still on <code>{rix}</code>’s repository, I define a new action that builds this environment periodically, but using the binary cache I set up with Cachix. You can find this action <a href="https://github.com/b-rodrigues/rix/blob/master/.github/workflows/cachix-dev-env.yml">here</a>. So the <code>r-daily</code> branch of our <code>nixpkgs</code> fork gets updated every 6 hour and this environment gets updated every 12 hours, 30 minutes past the hour.
</p>
<p>
Now, every time I want to work on my package, I simply use <code>nix-build</code> on my computer to update the development environment. This is what I see:
</p>
<pre><code>copying path '/nix/store/0l0iw4hz7xvykvhsjg8nqkvyl31js96l-r-stringr-1.5.1' from 'https://b-rodrigues.cachix.org'...
copying path '/nix/store/cw3lc7b0zydsricl5155jbmldm1vcyvr-r-tibble-3.2.1' from 'https://b-rodrigues.cachix.org'...
copying path '/nix/store/y32kpp09l34cdgksnr89cyvz6p5s94z8-r-tidyselect-1.2.1' from 'https://b-rodrigues.cachix.org'...
copying path '/nix/store/sw24yx1jwy9xzq8ai5m2gzaamvyi5r0h-r-rematch2-2.1.2' from 'https://b-rodrigues.cachix.org'...
copying path '/nix/store/z6b4vii7hvl9mc53ykxrwks1lkfzgmr4-r-dplyr-1.1.4' from 'https://b-rodrigues.cachix.org'...</code></pre>
<p>
as you can see, packages get pulled from my cache. Packages that are already available from the usual, public, <code>cache.nixos.org</code> don’t get rebuilt nor cached in mine; they simply continue getting pulled directly from there. This makes using the development environment very easy, and guarantees I’m always mirroring the state of packages released on CRAN. The other interesting thing is that I can use that cache with other actions. For example, <a href="https://github.com/b-rodrigues/rix/blob/master/.github/workflows/tests-r-via-nix.yaml">here</a> is the action that runs the unit tests included in the package in an environment that has Nix installed on it (some unit tests need Nix to be available to run). On line 25 you can see that we install Nix and set our fork as the repository to use:
</p>
<pre><code>nix_path: nixpkgs=https://github.com/rstats-on-nix/nixpkgs/archive/refs/heads/r-daily.tar.gz</code></pre>
<p>
and just below, we set up the cache:
</p>
<pre><code>- uses: cachix/cachix-action@v14
  with:
    name: b-rodrigues # this is the name of my cache</code></pre>
<p>
By using my cache, I make sure that the test runs with the freshest possible packages, and don’t run the risk of having a test succeed on an outdated environment. And you might have noticed that I am not authenticating to Cachix: to simply pull binaries, to authentication is needed!
</p>
<p>
Cachix has a free plan of up to 5Gb which is more than enough to set up several development environments like this, and is really, really, easy to set up, and it works on your computer and on Github Actions, as shown. If you want to use this development environment to contribute to <code>{rix}</code>, check out the instructions on <a href="https://github.com/b-rodrigues/rix/blob/master/CONTRIBUTING.md#development-environment">Contributing.md</a> file.
</p>
<p>
You can use the same approach to always have development environments ready for your different projects, and I will likely add the possibility to use this fork of <code>nixpkgs</code> with my <code>{rix}</code> package.
</p>
<p>
<em>Thanks to <a href="https://github.com/philipp-baumann">Philipp Baumann</a> for nudging me into the direction of using Cachix and showing the way!</em>
</p>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2024-04-04-nix_for_r_part_11.html</guid>
  <pubDate>Thu, 04 Apr 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 10 – contributing to nixpkgs</title>
  <link>https://b-rodrigues.github.io/posts/2024-02-29-nix_for_r_part_10.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/nix_parents.jpg" width="60%">
</p>
</div>
<p>
I’ve very recently started contributing to the <code>nixpkgs</code> repository of packages, which contains all the packages you can install from the Nix package manager. My contributions are fairly modest: I help fix R packages that need some tweaking to make them successfully build for Nix. Most of these fixes are very simple one-liners.
</p>
<p>
Most users of any free and open source tool rarely contribute to the development of this tool: I don’t think it is due to lack of skills and/or time or interest, but mostly because starting to contribute to a tool requires some knowledge that is rarely written down (even more so for an entire ecosystem). These tools and ecosystems grow organically, and if you’re not in the right spot at the right time or are not lucky enough to have kind people taking time to explain things to you, contributing might feel completely overwhelming.
</p>
<p>
Thankfully, I was very lucky to have found the small but very active community of R contributors to <code>nixpkgs</code> on <a href="https://matrix.to/#/#r:nixos.org">Matrix</a> which very kindly took the time to bring me up to speed!
</p>
<p>
I wanted to share my experiences in this blog post: but this blog post is not just going to be about me contributing to <code>nixpkgs</code> from the perspective of an R user (and giving you some pointers on how to start yourself), but also about how I built a report (let’s call it like that) to keep track of which R packages got fixed. This report is built using R, Nix, Github Actions and lists all the failed R package builds from Hydra (more on this later). The report gets updated every day automatically at midnight, and is accessible <a href="https://raw.githack.com/b-rodrigues/nixpkgs-r-updates-fails/targets-runs/output/r-updates-fails.html">here</a>. I also used a very minimalistic approach to build this: no <code>{tidyverse}</code> packages, and no Quarto. Why? Mostly just to keep dependencies at a minimum to accelerate CI/CD, but also for fun. And honestly, I must admit that base R is more than capable on its own and had forgotten that.
</p>
<section id="contributing-to-nixpkgs" class="level2">
<h2 class="anchored" data-anchor-id="contributing-to-nixpkgs">
Contributing to nixpkgs
</h2>
<p>
As explained in <a href="../posts/2023-12-19-nix_for_r_part_8.html">part 8</a>, <code>nixpkgs</code> is “nothing but” a huge GitHub repository containing thousands of Nix expressions. These expressions are then used to actually build the software that then gets installed by Nix. For example, <a href="https://github.com/NixOS/nixpkgs/blob/nixpkgs-unstable/pkgs/development/libraries/quarto/default.nix">this is the expression for Quarto</a>. As you can see, it starts by downloading the pre-compiled binary, and then applying “patches”. Essentially making sure that Quarto installed by Nix is able to find the other pieces installed by Nix that Quarto needs (Deno, Pandoc, Typst and so on). It then continues by installing Quarto itself (because we’re downloading a pre-compiled binary, <em>installation</em> consists in moving files in the right spot), finally some tests are executed (<code>quarto check</code>) and then some metadata is defined. Not every package is defined like this, with a single Nix expression, though. For example, individual R packages are not defined like this. Instead, every package from CRAN and Bioconductor gets built using only a handful of files that can be found <a href="https://github.com/NixOS/nixpkgs/tree/nixpkgs-unstable/pkgs/development/r-modules">here</a>.
</p>
<p>
(By the way, you can look for packages and find their associated Nix expressions on the <a href="https://search.nixos.org/packages?channel=unstable&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=quarto">NixOS package search</a>).
</p>
<p>
The way this works, is that periodically the <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/r-modules/generic-builder.nix"><code>generate-r-packages.R</code></a> script is run and generates the <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/r-modules/cran-packages.nix"><code>cran-packages.nix</code></a> file (and the equivalent Bioconductor files). For each package on CRAN, a line gets written in the script with the package’s name, its current version on CRAN, and very importantly its dependencies. For example, here is the line for <code>{dplyr}</code>:
</p>
<pre><code>dplyr = derive2 { name="dplyr"; version="1.1.4";
   sha256="1jsq8pj12bngy66xms486j8a65wxvyqs944q9rxkiaylsla08wyg";
   depends=[cli generics glue lifecycle magrittr pillar R6 rlang tibble tidyselect vctrs]; };</code></pre>
<p>
These dependencies are actually the packages that can be found in the <a href="https://github.com/tidyverse/dplyr/blob/main/DESCRIPTION"><code>DESCRIPTION</code></a> file under <code>Imports</code>. <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/r-modules/cran-packages.nix"><code>cran-packages.nix</code></a> (and the same goes for the Bioconductor equivalents, <code>bioc-packages.nix</code>, <code>bioc-annotation-packages.nix</code> and <code>bioc-experiment-packages.nix</code>) get imported in the <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/r-modules/default.nix"><code>default.nix</code></a> file. In it, another file, <code>generic-builder.nix</code> gets also imported, which contains a function that will attempt building the package. Most of the time this succeeds, but some packages require further tweaks. Packages that have a field <code>NeedsCompilation</code> in their DESCRIPTION files are usually candidates for further tweaking: these packages require system-level dependencies, which are often listed under <code>SystemRequirements</code> (but not always, which complicates matters). For example, the <code>{terra}</code> package has these system requirements listed in itself DESCRIPTION file:
</p>
<pre><code>SystemRequirements:  C++17, GDAL (&gt;= 2.2.3), GEOS (&gt;= 3.4.0), PROJ (&gt;= 4.9.3), sqlite3</code></pre>
<p>
so these also need to be added if we want to build them on Nix. But if we look at the line for <code>{terra}</code> in <code>cran-packages.nix</code>, this is what we see:
</p>
<pre><code>terra = derive2 { name="terra"; version="1.7-65"; 
  sha256="0m9s5am8l6il1q0skab614cx0qjsb1i9xcv6nm0sdzj7p9lrzkfl"; 
  depends=[Rcpp]; };</code></pre>
<p>
Only <code>{Rcpp}</code> is listed, which is a dependency, yes, but an R package dependency, not a system-level requirement. System-level requirements need to be added in the <code>default.nix</code> file manually. In the <code>default.nix</code>, you’ll find a long list of packages called <code>packagesWithNativeBuildInputs</code> and <code>packagesWithBuildInputs</code>. <em>NativeBuildInputs</em> and <em>BuildInputs</em> are Nix jargon for dependencies the package needs, at compile-time and then at run-time specifically. For example, <code>{Rcpp}</code> is a <em>BuildInput</em> of <code>{terra}</code>, while the system-level requirements are <em>NativeBuildInputs</em> (in the context of R packages though, this rarely matters. If you want more details, refer to <a href="https://gist.github.com/b-rodrigues/c677b59126d05d43347ed9623ddd5b0c">this Gist</a> I’ve forked).
</p>
<p>
For <code>{terra}</code>, this means that we need to add this line to the list <code>{packagesWithNativeBuildInputs}</code> (I simplified the syntax here a bit):
</p>
<pre><code>terra = [ gdal proj geos ];</code></pre>
<p>
<code>gdal</code>, <code>proj</code> and <code>geos</code> are the system requirements that need to be added for <code>{terra}</code> to build successfully on Hydra.
</p>
</section>
<section id="hydra" class="level2">
<h2 class="anchored" data-anchor-id="hydra">
Hydra
</h2>
<p>
<em>Hydra is a tool for continuous integration testing and software release that uses a purely functional language to describe build jobs and their dependencies</em> (source: <a href="https://hydra.nixos.org/build/248007843/download/1/hydra/#introduction">the Hydra Manual</a>)
</p>
<p>
If you’re coming from R, think of Hydra as <a href="https://builder.r-hub.io/">R-hub</a>, which will check and build your R package before submitting to CRAN. Hydra periodically tries to rebuild packages. If that package fails, then the log gets hosted. When it comes to R packages, we can check which packages built successfully or not on <a href="https://hydra.nixos.org/jobset/nixpkgs/r-updates">here</a>.
</p>
<p>
As of writing, the latest evaluation was in mid-January. A new release of R is going to get released on the 29th of February (or maybe was already released, I’m not sure when this blog post is going to get posted), and this is when new evaluations will likely be executed. Evaluations are the processes by which Nix expressions get… evaluated and used to actually build packages. So if we look into the results of the evaluation of the 17th of January, we see that 757 jobs failed:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/hydra_failing_jobs.jpg" width="80%">
</p>
</div>
<p>
One job doesn’t strictly correspond to one package though: packages get built for different architectures, and each architecture gets its build process. If we log into the details of the first package whose build failed <code>{AIUQ}</code>, we see this:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/hydra_failed.jpg" width="80%">
</p>
</div>
<p>
From the log we see that actually what failed one of its dependencies, <code>{SuperGauss}</code>, so fixing <code>{SuperGauss}</code> will likely fix <code>{AIUQ}</code> (I say likely because maybe another needed dependency also fails). So we could try to fix <code>{SuperGauss}</code> first. Let’s see why <code>{SuperGauss}</code>, by clicking on <code>raw</code>:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/hydra_failed_raw.jpg" width="80%">
</p>
</div>
<p>
Here is what we see:
</p>
<pre><code>Running phase: unpackPhase
unpacking source archive /nix/store/615bdvjchxrd7wp5m7dhg4g04yv7ncza-SuperGauss_2.0.3.tar.gz
source root is SuperGauss
setting SOURCE_DATE_EPOCH to timestamp 1645735202 of file SuperGauss/MD5
Running phase: patchPhase
Running phase: updateAutotoolsGnuConfigScriptsPhase
Running phase: configurePhase
Running phase: buildPhase
Running phase: checkPhase
Running phase: installPhase
* installing *source* package 'SuperGauss' ...
** package 'SuperGauss' successfully unpacked and MD5 sums checked
** using staged installation
checking for gcc... /nix/store/xq8920m5mbd83vdlydwli7qsh67gfm5v-gcc-wrapper-13.2.0/bin/cc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether /nix/store/xq8920m5mbd83vdlydwli7qsh67gfm5v-gcc-wrapper-13.2.0/bin/cc accepts -g... yes
checking for /nix/store/xq8920m5mbd83vdlydwli7qsh67gfm5v-gcc-wrapper-13.2.0/bin/cc option to accept ISO C89... none needed
checking for pkg-config... no
checking for FFTW... configure: error: in `/build/SuperGauss':
configure: error: The pkg-config script could not be found or is too old.  Make sure it
is in your PATH or set the PKG_CONFIG environment variable to the full
path to pkg-config.

Alternatively, you may set the environment variables FFTW_CFLAGS
and FFTW_LIBS to avoid the need to call pkg-config.
See the pkg-config man page for more details.

To get pkg-config, see &lt;http://pkg-config.freedesktop.org/&gt;.
See `config.log' for more details
ERROR: configuration failed for package 'SuperGauss'
* removing '/nix/store/jxv5p85x24xmfcnifw2ibvx9jhk9f2w4-r-SuperGauss-2.0.3/library/SuperGauss'</code></pre>
<p>
This is essentially what we would see if we tried to install <code>{SuperGauss}</code> on Linux. The error message is quite clear here: a system-level dependency, <code>pkg-config</code> is missing. Looks like we found our first package to fix!
</p>
</section>
<section id="fixing-a-package" class="level2">
<h2 class="anchored" data-anchor-id="fixing-a-package">
Fixing a package
</h2>
<p>
The first step is to fork and clone the <code>nixpkgs</code> GitHub repository to your computer (be patient, the repository is huge so the download will take some time):
</p>
<pre><code>git clone git@github.com:b-rodrigues/nixpkgs.git</code></pre>
<p>
It’s also a good idea to add the original <code>nixpkgs</code> as an <code>upstream</code>:
</p>
<pre><code>git remote add upstream https://github.com/NixOS/nixpkgs</code></pre>
<p>
This way, you can pull changes from the original <code>nixpkgs</code> repository into your fork easily with:
</p>
<pre><code>git fetch upstream master
git merge upstream/master</code></pre>
<p>
These two commands synchronize your local copy of the repository with upstream. So now we can create a new branch to try to fix <code>{SuperGauss}</code>:
</p>
<pre><code>git branch -b fix_supergauss</code></pre>
<p>
and then we should try to build <code>{SuperGauss}</code> locally. This is because it might have been fixed in the meantime by someone else, so let’s try to build it with (run the following command in a terminal at the root of your local copy of the <code>nixpkgs</code> repository):
</p>
<pre><code>nix-build -A rPackages.SuperGauss</code></pre>
<p>
but I often prefer to use this instead, because this will build the package and drop me into a shell where I can start R, load the package, and try it by running some of its examples:
</p>
<pre><code>nix-shell -I nixpkgs=/path/to/my/nixpkgs -p rPackages.SuperGauss R</code></pre>
<p>
If any of the commands above fail with the same error message as on Hydra, we know that it hasn’t been fixed yet. So the fix consists in opening the <code>pkgs/development/r-modules/default.nix</code> and add the following line:
</p>
<pre><code>SuperGauss = [ pkg-config ];</code></pre>
<p>
in either the lists <code>packagesWithBuildInputs</code> or <code>packagesWithNativeBuildInputs</code> (as explained above, it doesn’t really matter). Trying to rebuild <code>SuperGauss</code> again will result in a new error message. Another dependecy needs to be added:
</p>
<pre><code>SuperGauss = [ pkg-config fftw.dev ];</code></pre>
<p>
Then, building succeeds! We can now commit, push, and open a pull request. Commit messages need to be formatted in a certain way, as per <code>nixpkgs</code> <a href="https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md">contributing guide</a>, so:
</p>
<pre><code>git add .
git commit -m "rPackages.SuperGauss: add dependencies"</code></pre>
<p>
also, there should only be one commit per fix. So if in the process of fixing a package you commited several times, you will need to use <code>git rebase</code> to squash all the commits into one. Once you open the pull request, a maintainer will get pinged, and merge the PR if everything is alright (which is usually the case for these one-liners). You can see the PR for <code>{SuperGauss}</code> <a href="https://github.com/NixOS/nixpkgs/pull/287209">here</a>.
</p>
<p>
The process is relatively simple once you did it once or twice, but there are some issues: there is no easy way to find out on which packages we should focus on. For example, is <code>{SuperGauss}</code> really that important? The fix was very simple, so it’s ok, but if it took more effort, should we spend the limited time we have on it, or should we focus on another package? Also, if someone has already opened a PR to fix a package, but that PR hasn’t been merged yet, if I try to also fix the same package and try to build the package, it would still fail. So I might think that no one is taking care of it, and waste time duplicating efforts instead of either focusing on another package, or reviewing the open PR to accelerate the process of merging.
</p>
<p>
Discussing this with other contributors, <a href="https://fosstodon.org/deck/@kupac@functional.cafe">László Kupcsik</a> suggested we could use <code>{packageRank}</code> to find out which packages are getting a lot of downloads from CRAN, and so we could focus on fixing these packages first. This is a great idea and it gave me the idea to build some kind of report that would do this automatically for us, and also list opened and merged PRs so we wouldn’t risk duplicating efforts.
</p>
<p>
This report can be found <a href="https://raw.githack.com/b-rodrigues/nixpkgs-r-updates-fails/targets-runs/output/r-updates-fails.html">here</a> and now I’ll explain how I built it.
</p>
</section>
<section id="which-packages-to-fix-and-keeping-track-of-prs" class="level2">
<h2 class="anchored" data-anchor-id="which-packages-to-fix-and-keeping-track-of-prs">
Which packages to fix and keeping track of PRs
</h2>
<p>
So the main idea was to know on which packages to focus on. So essentially, we wanted this table:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/hydra_failing_jobs.jpg" width="80%">
</p>
</div>
<p>
but with <code>{packageRank}</code> added to it. So the first step was to scrape this table, using <code>{rvest}</code>. This is what you can find on lines 11 to 63 of this <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/_targets.R">{targets} workflow</a> (alongside some basic cleaning). I won’t go too much into detail, but if something’s not clear, ping me on <a href="https://twitter.com/brodriguesco">twitter</a> or <a href="https://fosstodon.org/@brodriguesco">Mastodon</a> or even open an issue on the report’s <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/issues">repository</a>.
</p>
<p>
Next I also get the reason the package failed building. So in the example from before, <code>{AIUQ}</code> failed because <code>{SuperGauss}</code> failed. On Hydra, you should be clicking to see this, but here I scrape it as well automatically, and add this information in a column called <code>fails_because_of</code>. This is what you can read on lines <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/_targets.R#L65">65 to 77</a>. I use a function called <code>safe_get_failed_deps()</code>, which you can find in the <code>functions.R</code> script <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/functions.R#L41C1-L68C2">on here</a>. <code>safe_get_failed_deps()</code> wraps the main function, <code>get_failed_deps()</code>, with <code>tryCatch()</code>. This is because if anything goes wrong, I want my function to return <code>NULL</code> instead of an error, which would crash the whole pipeline.
</p>
<p>
Next, I add the packages’ rank using a function that wraps <code>packageRank::packageRank()</code> called <code>safe_packageRank()</code> on <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/_targets.R#L97">line 97</a>.
</p>
<p>
<code>safe_packageRank()</code> uses <code>tryCatch()</code> to return <code>NULL</code> in case there’s an error. This is needed because <code>packageRank()</code> will only work on CRAN packages, but Hydra also tries to build Bioconductor packages: when these packages’ names get passed to <code>packageRank()</code>, an error gets returned because these are not CRAN packages:
</p>
<pre class="r"><code>packageRank("haha")
Error: haha: misspelled or not on CRAN/Archive.</code></pre>
<p>
but instead of an error that would stop the pipeline, I prefer it simply returns <code>NULL</code>, hence <code>tryCatch()</code>. Also, I compute the rank of the package listed under the <code>fails_because_of</code> column and not the <code>package</code> column. If we go back to our example from before, <code>{AIUQ}</code> failed because <code>{SuperGauss}</code> failed, I’m actually interested in the rank of <code>{SuperGauss}</code>, and not <code>{AIUQ}</code> (which I way I went to all the trouble to scrape the failing dependency).
</p>
<p>
So, for now, when comparing to the table on Hydra, we have two further columns with the dependency that actually fails (or not, if the package fails on its own and not because of a dependency), and the rank of either the dependency that fails or the package itself.
</p>
<p>
Next, I’d like to see if PRs have already been opened and merged. For this, I use the <code>gh</code> tool, which is a command line tool to interact with GitHub repositories. I wrote the <code>get_prs()</code> wrapper around <code>gh</code> to list the opened or the merged PRs of the <code>nixpkgs</code> repository. This is what it looks like (and is defined <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/functions.R#L8C1-L21C2">here</a>):
</p>
<pre><code>get_prs &lt;- function(state){

  output_path &lt;- paste0(state, "_prs.json")

  # Run the command
  system(paste0(
    "gh pr list --state=", state,
    " --search=rPackages -R NixOS/nixpkgs --json title,updatedAt,url &gt; ",
    output_path
  ))

  # Return path for targets
  output_path
}</code></pre>
<p>
Because the PRs follow the contributing guidelines, I can easily process the PRs titles to get the name of the package (I essentially need to go from the string “rPackages.SuperGauss: fixing build” to “SuperGauss”) using regular expressions. This is what happens in the <code>clean_prs()</code> function <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/functions.R#L23">here</a>.
</p>
<p>
Most of what follows is merging the right data frames and ensuring that I have something clean to show. Finally, an <code>.Rmd</code> document gets compiled, which you can find <a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/r-updates-fails.Rmd">here</a>. This will get compiled to an <code>.html</code> file which is what you see when you click <a href="https://raw.githack.com/b-rodrigues/nixpkgs-r-updates-fails/targets-runs/output/r-updates-fails.html">here</a>.
</p>
<p>
This runs every day at midnight using GitHub actions (<a href="https://github.com/b-rodrigues/nixpkgs-r-updates-fails/blob/0fe273dd234f0d32e5fae86630173ff42cce2d9f/.github/workflows/compile_table.yaml">the workflow is here</a>) and then I use the <code>raw.githack.com</code> <a href="https://raw.githack.com/">here</a> to serve the rendered HTML file. So every time I push, or at midnight, the action runs, computes the package rank, checks if new PRs are available or have been merged, and the rendered file is immediately available. How’s that for serverless CI/CD?
</p>
<p>
If you are interested in using Nix to make your analyses reproducible, check out <a href="https://b-rodrigues.github.io/blog/index.html#category=nix">the other blog posts in this series</a> and join our small but motivated community of R contributors to <code>nixpkgs</code> on <a href="https://matrix.to/#/#r:nixos.org">Matrix</a>. If you are interested in the history of Nix, checkout this super interesting <a href="https://economicsfromthetopdown.com/2024/02/17/nixing-technological-lock-in/">blog post</a> by <a href="https://mastodon.online/@blair_fix">Blair Fix</a>.
</p>
<p>
If you’re interested into using project-specific, and reproducible development environments, give <code>{rix}</code> and Nix a try! Learn more about <code>{rix}</code> on its Github repository <a href="https://github.com/b-rodrigues/rix">here</a> or <a href="https://docs.ropensci.org/rix/index.html">website</a>. We wrote many vignettes that are conveniently numbered, so don’t hesitate to <a href="https://docs.ropensci.org/rix/articles/a-getting-started.html">get started</a>!
</p>
<p>
<em>Thanks to the colleagues of the Matrix nixpkgs R channel for the fruitful discussions that helped shape this blog post and for proof-reading.</em>
</p>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2024-02-29-nix_for_r_part_10.html</guid>
  <pubDate>Thu, 29 Feb 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 9 – rix is looking for testers!</title>
  <link>https://b-rodrigues.github.io/posts/2024-02-02-nix_for_r_part_9.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/kick_rix.png">
</p>
</div>
<p>
After 5 months of work, <a href="https://github.com/philipp-baumann">Philipp Baumann</a> and myself are happy to announce that our package, <code>{rix}</code> is getting quite close to being in a state we consider “done” (well, at least, for a first release). We plan on submit it first to <a href="https://ropensci.org/software-review/">rOpenSci</a> for review, and later to CRAN. But in the meantime, if you could test the package, we’d be grateful! We are especially interested to see if you find the documentation clear, and if you are able to run the features that require an installation of Nix, the <code>nix_build()</code> and <code>with_nix()</code> functions. And I would truly recommend you read this blog post to the end, because I guarantee you’ll have your mind blown! If that’s not the case, send an insult my way on social media.
</p>
<section id="what-is-rix" class="level2">
<h2 class="anchored" data-anchor-id="what-is-rix">
What is rix?
</h2>
<p>
<code>{rix}</code> is an R package that leverages Nix, a powerful package manager focusing on reproducible builds. With Nix, it is possible to create project-specific environments that contain a project-specific version of R and R packages (as well as other tools or languages, if needed). You can use <code>{rix}</code> and Nix to replace renv and Docker with one single tool. Nix is an incredibly useful piece of software for ensuring reproducibility of projects, in research or otherwise, or for running web applications like Shiny apps or plumber APIs in a controlled environment. The advantage of using Nix over Docker is that the environments that you define using Nix are not isolated from the rest of your machine: you can still access files and other tools installed on your computer.
</p>
<p>
For example, here is how you could use <code>{rix}</code> to generate a file called <code>default.nix</code>, which can then be used by Nix to actually build that environment for you:
</p>
<pre class="r"><code>library(rix)

path_default_nix &lt;- tempdir()

rix(r_ver = "latest",
    r_pkgs = c("dplyr", "ggplot2"),
    system_pkgs = NULL,
    git_pkgs = NULL,
    ide = "code",
    shell_hook = NULL,
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE)</code></pre>
<pre><code>## # This file was generated by the {rix} R package v0.5.1.9000 on 2024-02-02
## # with following call:
## # &gt;rix(r_ver = "5ad9903c16126a7d949101687af0aa589b1d7d3d",
## #  &gt; r_pkgs = c("dplyr",
## #  &gt; "ggplot2"),
## #  &gt; system_pkgs = NULL,
## #  &gt; git_pkgs = NULL,
## #  &gt; ide = "code",
## #  &gt; project_path = path_default_nix,
## #  &gt; overwrite = TRUE,
## #  &gt; print = TRUE,
## #  &gt; shell_hook = NULL)
## # It uses nixpkgs' revision 5ad9903c16126a7d949101687af0aa589b1d7d3d for reproducibility purposes
## # which will install R version latest
## # Report any issues to https://github.com/b-rodrigues/rix
## let
##  pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/5ad9903c16126a7d949101687af0aa589b1d7d3d.tar.gz") {};
##  rpkgs = builtins.attrValues {
##   inherit (pkgs.rPackages) dplyr ggplot2 languageserver;
## };
##    system_packages = builtins.attrValues {
##   inherit (pkgs) R glibcLocales nix ;
## };
##   in
##   pkgs.mkShell {
##     LOCALE_ARCHIVE = if pkgs.system == "x86_64-linux" then  "${pkgs.glibcLocales}/lib/locale/locale-archive" else "";
##     LANG = "en_US.UTF-8";
##     LC_ALL = "en_US.UTF-8";
##     LC_TIME = "en_US.UTF-8";
##     LC_MONETARY = "en_US.UTF-8";
##     LC_PAPER = "en_US.UTF-8";
##     LC_MEASUREMENT = "en_US.UTF-8";
## 
##     buildInputs = [  rpkgs  system_packages  ];
##       
##   }</code></pre>
<p>
You don’t need to have Nix installed to use <code>{rix}</code> and generate this expression! This is especially useful if you want to generate an expression that should then be used in a CI/CD environment for example.
</p>
<p>
But if you do have Nix installed, then you can use two great functions that Philipp implemented, which we are really excited to tell you about!
</p>
</section>
<section id="nix_build-and-with_nix" class="level2">
<h2 class="anchored" data-anchor-id="nix_build-and-with_nix">
nix_build() and with_nix()
</h2>
<p>
When you have a <code>default.nix</code> file that was generated by <code>rix::rix()</code>, and if you have Nix installed on your system, you can build the corresponding environment using the command line tool <code>nix-build</code>. But you can also build that environment straight from an R session, by using <a href="https://b-rodrigues.github.io/rix/reference/nix_build.html"><code>rix::nix_build()</code></a>!
</p>
<p>
But the reason <a href="https://b-rodrigues.github.io/rix/reference/nix_build.html"><code>nix_build()</code></a> is really useful, is because it gets called by <a href="https://b-rodrigues.github.io/rix/reference/with_nix.html"><code>with_nix()</code></a>. <a href="https://b-rodrigues.github.io/rix/reference/with_nix.html"><code>with_nix()</code></a> is a very interesting function, because it allows you to evaluate a single function within a so-called subshell. That subshell can have a whole other version of R and R packages than your main session, and you can use it to execute an arbitrary function (or a whole, complex expression), and then get the result back into your main session. You could use older versions of packages to get a result that might not be possible to get in a current version. Consider the following example: on a recent version of <code>{stringr}</code>, <code>stringr::str_subset(c(““,”a”), ““)</code> results in an error, but older versions would return <code>”a”</code>. Returning an error is actually what this should do, but hey, if you have code that relies on that old behaviour you can now execute that old code within a subshell that contains that older version of <code>{stringr}</code>. Start by creating a folder to contain everything needed for your subshell:
</p>
<pre class="r"><code>path_env_stringr &lt;- file.path(".", "_env_stringr_1.4.1")</code></pre>
<p>
Then, it is advised to use <a href="https://b-rodrigues.github.io/rix/reference/rix_init.html"><code>rix::rix_init()</code></a> to generate an <code>.Rprofile</code> for that subshell, which sets a number of environment variables. This way, when the R session in that subshell starts, we don’t have any interference between that subshell and the main R session, as the R packages that must be available to the subshell are only taken from the Nix store. The Nix store is where software installed by Nix is… stored, and we don’t want R to be confused and go look for R packages in the user’s library, which could happen without this specific <code>.Rprofile</code> file:
</p>
<pre class="r"><code>rix_init(
  project_path = path_env_stringr,
  rprofile_action = "overwrite",
  message_type = "simple"
)</code></pre>
<pre><code>## 
## ### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###
## 
## ==&gt; Created isolated nix-R project folder:
##  /home/cbrunos/six_to/dev_env/b-rodrigues.github.com/content/blog/_env_stringr_1.4.1 
## ==&gt; R session running via Nix (nixpkgs)
## * R session not running from RStudio
## ==&gt; Added `.Rprofile` file and code lines for new R sessions launched from:
## /home/cbrunos/six_to/dev_env/b-rodrigues.github.com/content/blog/_env_stringr_1.4.1
## 
## * Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:
## /nix/var/nix/profiles/default/bin</code></pre>
<p>
We now generate the <code>default.nix</code> file for that subshell:
</p>
<pre class="r"><code>rix(
  r_ver = "latest",
  r_pkgs = "stringr@1.4.1",
  overwrite = TRUE,
  project_path = path_env_stringr
)</code></pre>
<p>
Notice how we use the latest version of R (we could have used any other), but <code>{stringr}</code> on version 1.4.1. Finally, we use <code>with_nix()</code> to evaluate <code>stringr::str_subset(c(““,”a”), ““)</code> inside that subshell:
</p>
<pre class="r"><code>out_nix_stringr &lt;- with_nix(
  expr = function() stringr::str_subset(c("", "a"), ""),
  program = "R",
  exec_mode = "non-blocking",
  project_path = path_env_stringr,
  message_type = "simple"
)</code></pre>
<pre><code>## * R session not running from RStudio
## ### Prepare to exchange arguments and globals for `expr` between the host and Nix R sessions ###
## * checking code in `expr` for potential problems:
##  `codetools::checkUsage(fun = expr)`
## 
## * checking code in `expr` for potential problems:
## 
## * checking code in `globals_exprs` for potential problems:
## 
## ==&gt; Running deparsed expression via `nix-shell` in non-blocking mode:
## 
## 
## ==&gt; Process ID (PID) is 19688.
## ==&gt; Receiving stdout and stderr streams...
## 
## ==&gt; `expr` succeeded!
## ### Finished code evaluation in `nix-shell` ###
## 
## * Evaluating `expr` in `nix-shell` returns:
## [1] "a"</code></pre>
<p>
Finally, we can check if the result is really <code>“a”</code> or not:
</p>
<pre class="r"><code>identical("a", out_nix_stringr)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>
<code>with_nix()</code> should work whether you installed your main R session using Nix, or not, but we’re not sure this is true for Windows (or rather, WSL2): we don’t have a Windows license to test this on Windows, so if you’re on Windows and use WSL2 and want to test this, we would be very happy to hear from you!
</p>
<p>
If you’re interested into using project-specific, and reproducible development environments, give <code>{rix}</code> and Nix a try! Learn more about <code>{rix}</code> on its Github repository <a href="https://github.com/b-rodrigues/rix">here</a> or <a href="https://docs.ropensci.org/rix/">website</a>. We wrote many vignettes that are conveniently numbered, so don’t hesitate to <a href="https://docs.ropensci.org/rix/articles/a-getting-started.html">get started</a>!
</p>


</section>

 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2024-02-02-nix_for_r_part_9.html</guid>
  <pubDate>Fri, 02 Feb 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 8 – nixpkgs, a tale of the magic of free and open source software and a call for charity</title>
  <link>https://b-rodrigues.github.io/posts/2023-12-19-nix_for_r_part_8.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/santa_tux.jpg" width="100%">
</p>
</div>
<p>
<em>This is part 8 of a series of blog posts about Nix. Check out the other parts <a href="https://b-rodrigues.github.io/blog/index.html#category=nix">here</a>. TLDR: free and open source software is one of the most important common goods with enormous positive externalities: if you want to help funding it, keep reading!</em>
</p>
<p>
I wanted to quickly discuss about <code>nixpkgs</code>, which is the collection of packages that can be installed using Nix. Why is a project like Nix and <code>nixpkgs</code> important, even if you don’t use Nix? In actuality, you may not realise it, but you very much benefit from projects like Nix even if you don’t use it. Let me explain.
</p>
<p>
<code>nixpkgs</code> is “just” a Github repository containing thousands upon thousands of Nix expressions. When installing a package, these expressions get evaluated, and the package in question gets installed. What <em>installed</em> means can vary: sometimes the package gets built from source, sometimes a pre-compiled binary package for your operating system gets downloaded and installed.
</p>
<p>
For example, <a href="https://github.com/NixOS/nixpkgs/blob/dce218f4f35440622d2056f93ddc335351763bb4/pkgs/development/libraries/quarto/default.nix">here</a> is the Nix expression that downloads and installs Quarto. This is an example of an expression that downloads the pre-compiled Quarto package from Quarto’s own Github repository, and then <em>installs</em> it. The installation process in this case is essentially making sure that Quarto is able to find its dependencies, which also get installed from Nix, and some R and Python packages to make Quarto work well with both languages also get installed.
</p>
<p>
Because Nix packages are “nothing but” Nix expressions hosted on Github, contributing to Nix is as simple as opening a PR. For example, <a href="https://github.com/NixOS/nixpkgs/pull/263108">here</a> is a draft PR I opened to prepare for the imminent release of Quarto <code>1.4</code>. My goal when I opened this draft PR was to get used to contributing to <code>nixpkgs</code> (this was my second or third PR to <code>nixpkgs</code>, and I did some rookie mistakes when opening my first ones) and also to make the latest version of Quarto available on Nix as quickly as possible. But this PR had an unexpected consequence: through it, we found a bug in Quarto, which was then fixed before the actual release of the next version!
</p>
<p>
You see, how these things work is that when software gets released, operating system specific packages get built downstream. In the case of Quarto, this is not entirely true though: the developers of Quarto release many pre-compiled packages for Windows, macOS and several Linux distribution themselves. But they don’t do so for many other operating systems (which is entirely normal: there’s just too many! So releasing pre-built binaries for the main operating systems is more than enough), so the maintainers of these other operating systems (or package managers) have to package the software themselves. In the case of scientific software like Quarto, this usually means that it must get packaged for the Conda package manager (popular among Python users) and Nix (and there’s certainly other package managers out there that provide Quarto for other <em>exotic</em> systems) (Note: in the case of Quarto, I think the Quarto devs themselves also package it for Conda, though).
</p>
<p>
Turns out that when trying to package the pre-releases of Quarto for Nix, we discovered a regression in the upstream code that would not only affect packaging for Nix, but also for other package managers. We opened an issue on <a href="https://github.com/quarto-dev/quarto-cli/issues/7344">Quarto’s issue tracker</a> and after some discussion, the bug was identified and adressed in a matter of hours. And now everyone gets to enjoy a better version of Quarto!
</p>
<p>
This type of thing happens quite a lot in the background of open source development. My mind always gets blown when I think about the enormous amount of hours that get put by hobbyists and paid developers into open source and how well everything works. Truly a Christmas miracle (but one that happens all around the year)!
</p>
<p>
But it’s not all good and perfect. Some software is more complex to package, and requires much more work. For example the RStudio IDE is one of these. It’s a complex piece of software with many dependencies, and while it is available on Nix, it can only be installed on Windows and Linux. If you’re a Nix user on macOS, you won’t be able to install RStudio, unfortunately. And, unfortunately also, if you install RStudio using the usual macOS installer, it won’t be able to find any version of R and R packages installed with Nix. This is because RStudio needs to be patched to make it work nicely with Nix (just like we have to patch and prepare Quarto to play well with Nix). And packaging Rstudio for Nix on macOS requires some expertise and hardware that we R users/contributers to Nix don’t have all have access to.
</p>
<p>
This is where I appeal to your generosity: I have contacted a company called Numtide which offers a packaging service. You tell them which software you want on Nix, they write the expression and open a PR to <code>nixpkgs</code>. But this costs money: so I started a Gofundme which you can find <a href="https://www.gofundme.com/f/package-rstudio-for-nix-on-macos-platforms">here</a> to fund this. The goal is 4500€, which would cover the work, plus Gofundme fees and interest rate risk. I stated in the Gofundme that if the goal was not reached until the end of the year, I would donate all the money to the R foundation, but I might extend it to end of January 2024 instead.
</p>
<p>
So here is my ask: if you want to help make free and open source software better, consider donating to this Gofundme! As explained above, even if you don’t use Nix, everyone can benefit from work that is done by everyone, be it upstream or downstream. And if the goal is not met, your donation will go to the R foundation anyways!
</p>
<p>
The link to the Gofundme is <a href="https://www.gofundme.com/f/package-rstudio-for-nix-on-macos-platforms">here</a>.
</p>
<p>
I hope you can help out with this and make free and open source available and better for everyone.
</p>
<p>
Many thanks, merry Christmas and happy new year!
</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2023-12-19-nix_for_r_part_8.html</guid>
  <pubDate>Tue, 19 Dec 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 7 – Building a Quarto book using Nix on Github Actions</title>
  <link>https://b-rodrigues.github.io/posts/2023-10-20-nix_for_r_part7.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/nix_users_press_both_buttons.png" width="50%">
</p>
</div>
<p>
Back in June I self-published a book on Amazon’s Kindle Direct Publishing service and wrote a blog post detailling how you could achieve that using Quarto, which you can read <a href="../posts/2023-06-29-book_quarto.html">here</a>. The book is about <a href="https://b-rodrigues.github.io/blog/books.html">building reproducible analytical pipelines with R</a>. For the purposes of this post I made a <a href="https://github.com/b-rodrigues/kdp_quarto">template on Github</a> that you could fork and use as a starting point to write your own book. The book also gets built using Github Actions each time you push new changes: a website gets built, an E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built. That template used dedicated actions to install the required version of R, Quarto, and R packages (using <code>{renv}</code>).
</p>
<p>
Let’s take a look at the workflow file:
</p>
<pre><code>on:
  push:
    branches: main

name: Render and Publish

jobs:
  build-deploy:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup pandoc
        uses: r-lib/actions/setup-pandoc@v2

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.3.1'

      - name: Setup renv
        uses: r-lib/actions/setup-renv@v2

      - name: Set up Quarto
        uses: quarto-dev/quarto-actions/setup@v2
        with:
          # To install LaTeX to build PDF book 
          tinytex: true 
          # uncomment below and fill to pin a version
          #version: 1.3.353

      - name: Publish to GitHub Pages (and render)
        uses: quarto-dev/quarto-actions/publish@v2
        with:
          target: gh-pages
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions</code></pre>
<p>
As you can see, there are a lot of different moving pieces to get this to work. Since then I discovered Nix (if you’ve not been following my adventures, there’s 6 other parts to this series as of today), and now I wrote another template that uses Nix to handle the book’s dependencies instead of dedicated actions and <code>{renv}</code>. You can find the repository <a href="https://github.com/b-rodrigues/quarto_book_nix">here</a>.
</p>
<p>
Here is what the workflow file looks like:
</p>
<pre><code>name: Build book using Nix

on:
  push:
    branches:
      - main
      - master

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main
      with:
        logger: pretty
        log-directives: nix_installer=trace
        backtrace: full

    - name: Nix cache
      uses: DeterminateSystems/magic-nix-cache-action@main

    - name: Build development environment
      run: |
        nix-build

    - name: Publish to GitHub Pages (and render)
      uses: b-rodrigues/quarto-nix-actions/publish@main
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} </code></pre>
<p>
The first thing you should notice is that this file is much shorter.
</p>
<p>
The first step, <code>Checkout Code</code> makes the code available to the rest of the steps. I then install Nix on this runner using the Determinate Systems <code>nix-installer-action</code> and then I use another action from Determinate Systems, the <code>magic-nix-cache-action</code>. This action caches all the packages so that they don’t need to get re-built each time a change gets pushed, speeding up the process by a lot. The development environment gets then built using <code>nix-build</code>.
</p>
<p>
Finally, an action I defined runs, <code>quarto-nix-actions/publish</code>. This is a fork of the <code>quarto-actions/publish</code> action which you can find <a href="https://github.com/quarto-dev/quarto-actions/blob/main/publish/action.yml">here</a>. My fork simply makes sure that the <code>quarto render</code> and <code>quarto publish</code> commands run in the <a href="https://github.com/b-rodrigues/quarto-nix-actions/blob/f48f5a7813eb4978a2f557ff45bcc854526fb80b/publish/action.yml#L58">Nix environment defined for the project</a>.
</p>
<p>
You can see the book website <a href="https://b-rodrigues.github.io/quarto_book_nix/">here</a>; read it, it’s explains everything in much more details than this blog post! But if you’re busy, read continue reading this blog post instead.
</p>
<p>
The obvious next question is why bother with this second, Nix-centric, approach?
</p>
<p>
There are at least three reasons. The first is that it is possible to define so-called <code>default.nix</code> files that the Nix package manager then uses to build a fully reproducible development environment. This environment will contain all the packages that you require, and will not interfere with any other packages installed on your system. This essentially means that you can have project-specific <code>default.nix</code> files, each specifying the requirements for specific projects. This file can then be used as-is on any other platform to re-create your environment. The second reason is that when installing a package that requires system-level dependencies, <code>{rJava}</code> for example, all the lower-level dependencies get automatically installed as well. Forget about reading error messages of <code>install.packages()</code> to find which system development library you need to install first. The third reason is that you can pin a specific revision of <code>nixpkgs</code> to ensure reproducibility.
</p>
<p>
The <code>nixpkgs</code> mono-repository is “just” a Github repository which you can find here: <a href="https://github.com/NixOS/nixpkgs">https://github.com/NixOS/nixpkgs</a>. This repository contains Nix expressions to build and install more than 80’000 packages and you can search for installable Nix packages <a href="https://search.nixos.org/packages">here</a>.
</p>
<p>
Because <code>nixpkgs</code> is a “just” Github repository, it is possible to use a specific commit hash to install the packages as they were at a specific point in time. For example, if you use this commit, <code>7c9cc5a6e</code>, you’ll get the very latest packages as of the 19th of October 2023, but if you used this one instead: <code>976fa3369</code>, you’ll get packages from the 19th of August 2023.
</p>
<p>
This ability to deal with both underlying system-level dependencies and pin package versions at a specific commit is extremely useful on Git(Dev)Ops platforms like Github Actions. Debugging installation failures of packages can be quite frustrating, especially on Github Actions, and especially if you’re not already familiar with how Linux distributions work. Having a tool that handles all of that for you is amazing. The difficult part is writing these <code>default.nix</code> files that the Nix package manager requires to actually build these development environments. But don’t worry, with my co-author <a href="https://github.com/philipp-baumann">Philipp Baumann</a>, we developed an R package called <code>{rix}</code> which generates these <code>default.nix</code> files for you.
</p>
<p>
<code>{rix}</code> is an R package that makes it very easy to generate very complex <code>default.nix</code> files. These files can in turn be used by the Nix package manager to build project-specific environments. The book’s Github repository contains a file called <code>define_env.R</code> with the following content:
</p>
<pre class="r"><code>library(rix)

rix(r_ver = "4.3.1",
    r_pkgs = c("quarto"),
    system_pkgs = "quarto",
    tex_pkgs = c(
      "amsmath",
      "framed",
      "fvextra",
      "environ",
      "fontawesome5",
      "orcidlink",
      "pdfcol",
      "tcolorbox",
      "tikzfill"
    ),
    ide = "other",
    shell_hook = "",
    project_path = ".",
    overwrite = TRUE,
    print = TRUE)</code></pre>
<p>
<code>{rix}</code> ships the <code>rix()</code> function which takes several arguments. These arguments allow you to specify an R version, a list of R packages, a list of system packages, TeXLive packages and other options that allow you to specify your requirements. Running this code generates this <code>default.nix</code> file:
</p>
<pre><code># This file was generated by the {rix} R package v0.4.1 on 2023-10-19
# with following call:
# &gt;rix(r_ver = "976fa3369d722e76f37c77493d99829540d43845",
#  &gt; r_pkgs = c("quarto"),
#  &gt; system_pkgs = "quarto",
#  &gt; tex_pkgs = c("amsmath",
#  &gt; "framed",
#  &gt; "fvextra",
#  &gt; "environ",
#  &gt; "fontawesome5",
#  &gt; "orcidlink",
#  &gt; "pdfcol",
#  &gt; "tcolorbox",
#  &gt; "tikzfill"),
#  &gt; ide = "other",
#  &gt; project_path = ".",
#  &gt; overwrite = TRUE,
#  &gt; print = TRUE,
#  &gt; shell_hook = "")
# It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes
# which will install R version 4.3.1
# Report any issues to https://github.com/b-rodrigues/rix
let
 pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz") {};
 rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) quarto;
};
  tex = (pkgs.texlive.combine {
  inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;
});
 system_packages = builtins.attrValues {
  inherit (pkgs) R glibcLocalesUtf8 quarto;
};
  in
  pkgs.mkShell {
    LOCALE_ARCHIVE = if pkgs.system == "x86_64-linux" then  "${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive" else "";
    LANG = "en_US.UTF-8";
    LC_ALL = "en_US.UTF-8";
    LC_TIME = "en_US.UTF-8";
    LC_MONETARY = "en_US.UTF-8";
    LC_PAPER = "en_US.UTF-8";
    LC_MEASUREMENT = "en_US.UTF-8";

    buildInputs = [  rpkgs tex system_packages  ];
  }</code></pre>
<p>
This file defines the environment that is needed to build your book: be it locally on your machine, or on a GitOps platform like Github Actions. All that matters is that you have the Nix package manager installed (thankfully, it’s available for Windows –through WSL2–, Linux and macOS).
</p>
<p>
Being able to work locally on a specific environment, defined through code, and use that environment on the cloud as well, is great. It doesn’t matter that the code runs on Ubuntu on the Github Actions runner, and if that operating system is not the one you use as well. Thanks to Nix, your code will run on exactly the same environment. Because of that, you can use <code>ubuntu-latest</code> as your runner, because exactly the same packages will always get installed. This is not the case with my first template that uses dedicated actions and <code>{renv}</code>: there, the runner uses <code>ubuntu-22.04</code>, a fixed version of the Ubuntu operating system. The risk here, is that once these runners get decommissioned (Ubuntu 22.04 is a <em>long-term support</em> release of Ubuntu, so it’ll stop getting updated sometime in 2027), my code won’t be able to run anymore. This is because there’s no guarantee that the required version of R, Quarto, and all the other packages I need will be installable on that new release of Ubuntu. So for example, suppose I have the package <code>{foo}</code> at version 1.0 that requires the system-level development library <code>bar-dev</code> at version 0.4 to be installed on Ubuntu. This is not an issue now, as Ubuntu 22.04 ships version 0.4 of <code>bar-dev</code>. But it is very unlikely that the future version of Ubuntu from 2027 will ship that version, and there’s no guarantee my package will successfully build and work as expected with a more recent version of <code>bar-dev</code>. With Nix, this is not an issue; because I pin a specific commit of <code>nixpkgs</code>, not only will <code>{foo}</code> at version 1.0 get installed, its dependency <code>bar-dev</code> at version 0.4 will get installed by Nix as well, and get used to build <code>{foo}</code>. It doesn’t matter that my underlying operating system ships a more recent version of <code>bar-dev</code>. I really insist on this point, because this is not something that you can easily deal with, even with Docker. This is because when you use Docker, you need to be able to rebuild the image as many times as you need (the alternative is to store, forever, the built image), and just like for Github Actions runners, the underlying Ubuntu image will be decommissioned and stop working one day.
</p>
<p>
In other words, if you need long-term reproducibility, you should really consider using Nix, and even if you don’t need long-term reproducibility, you should really consider using Nix. This is because Nix makes things much easier. But there is one point where Nix is at a huge disadvantage when compared to the alternatives: the entry cost is quite high, as I’ve discussed in my <a href="../posts/2023-10-05-repro_overview.html">previous blog post</a>. But I’m hoping that through my blog posts, this entry cost is getting lowered for R users!
</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2023-10-20-nix_for_r_part7.html</guid>
  <pubDate>Fri, 20 Oct 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>An overview of what’s out there for reproducibility with R</title>
  <link>https://b-rodrigues.github.io/posts/2023-10-05-repro_overview.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/like_this.jpg" width="100%">
</p>
</div>
<p>
In this short blog post I’ll be summarizing what I learnt these past years about reproducibility with R. I’ll give some high-level explanations about different tools and then link to different blog posts of mine.
</p>
<p>
I see currently two main approaches with some commonalities, so let’s start with the commonalities.
</p>
<section id="commonalities" class="level2">
<h2 class="anchored" data-anchor-id="commonalities">
Commonalities
</h2>
<p>
These are aspects that I think will help you build reproducible projects, but that are not strictly necessary. These are:
</p>
<ul>
<li>
Git for code versioning;
</li>
<li>
unit tests (be it on your code or data);
</li>
<li>
literate programming;
</li>
<li>
packaging code;
</li>
<li>
build automation.
</li>
</ul>
<p>
I think that these aspects are really very important nice-to-haves, but depending on the project you might not have to use all these tools or techniques (but I would really recommend that you think very hard about these requirements and make sure that you actually, really, don’t need them).
</p>
<p>
What’s also important is how you organize the work if you’re in a team. Making sure that everyone is on the same page and uses the same tools and approaches is very important.
</p>
<p>
Now that we have the commonalities out of the way, let’s discuss the “two approaches”. Let’s start by the most popular one.
</p>
</section>
<section id="docker-and-something-else" class="level2">
<h2 class="anchored" data-anchor-id="docker-and-something-else">
Docker and “something else”
</h2>
<p>
Docker is a very popular containerisation solution. The idea is to build an <em>image</em> that contains everything needed to run and rebuild your project in a single command. You can add a specific version of R with the required packages in it, your project files and so on. You could even add the data directly into the image or provide the required data at run-time, it’s up to you.
</p>
<p>
The “something else” can be several things, but they all deal with the problem of providing the right packages for your analysis. You see, if you run an analysis today, you’ll be using certain versions of packages. The same versions of packages need to be made available inside that Docker image. To do so, a popular choice for R users is to use <a href="https://rstudio.github.io/renv/index.html">{renv}</a>, but there’s also <a href="https://groundhogr.com/">{groundhog}</a> and <a href="https://github.com/gesistsa/rang">{rang}</a>. You could also use CRAN snapshots from the <a href="https://packagemanager.posit.co/client/#/repos/cran/setup?snapshot=2023-09-25&amp;r_environment=other">Posit Public Package Manager</a>. Whatever you choose, Docker by itself is not enough: Docker provides a base where you can then add these other things on top.
</p>
<p>
To know more, read this:
</p>
<ul>
<li>
<a href="../posts/2022-11-19-raps.html">https://www.brodrigues.co/blog/2022-11-19-raps/</a>
</li>
<li>
<a href="../posts/2022-11-30-pipelines-as.html">https://www.brodrigues.co/blog/2022-11-30-pipelines-as/</a>
</li>
<li>
<a href="../posts/2023-05-08-dock_dev_env.html">https://www.brodrigues.co/blog/2023-05-08-dock_dev_env/</a>
</li>
<li>
<a href="2023-01-12-repro_r.qmd">https://www.brodrigues.co/blog/2023-01-12-repro_r/</a>
</li>
</ul>
<p>
By combining Docker plus any of the other packages listed above (or by using the PPPM) you can quite easily build reproducible projects, because what you end up doing, is essentially building something like a capsule that contains everything needed to run the project (this capsule is what is called an <em>image</em>). Then, you don’t run R and the scripts to build the project, you run the image, and within that image, R is executed on the provided scripts. This running instance of an image is called a <em>container</em>. This approach is by far the most popular and can even be used on Github Actions if your project is hosted on Github. On a scale from 1 to 10, I would say that the entry cost is about 3 if you already have some familiarity with Linux, but can go up to 7 if you’ve never touched Linux. What does Linux have to do with all this? Well, the Docker images that you are going to build will be based on Linux (most of the time the Ubuntu distribution) so familiarity with Linux or Ubuntu is a huge plus. You could use <code>{renv}</code>, <code>{rang}</code> or <code>{groundhog}</code> without Docker, directly on your PC, but the issue here is that your operating system and the version of R changes through time. And both of these can have an impact on the reproducibility of your project. Hence, why we use Docker to, in a sense, “freeze” both the underlying operating system and version of R inside that image, and then, every container executed from that image will have the required versions of software.
</p>
<p>
One issue with Docker is that if you build an image today, the underlying Linux distribution will get out of date at some point, and you won’t be able to rebuild the image. So you either need to build the image and store it forever, or you need to maintain your image and port your code to newer base Ubuntu images.
</p>
</section>
<section id="nix" class="level2">
<h2 class="anchored" data-anchor-id="nix">
Nix
</h2>
<p>
Nix is a package manager for Linux (and Windows through WSL) and macOS, but also a programming language that focuses on reproducibility of software builds, meaning that using Nix it’s possible to build software in a completely reproducible way. Nix is incredibly flexible, so it’s also possible to use it to build reproducible development environments, or run reproducible analytical pipelines. What Nix doesn’t easily allow, unlike <code>{renv}</code> for example, is to install a specific version of one specific package. But I also wrote a package called <a href="https://b-rodrigues.github.io/rix/">{rix}</a> (co-authored by Philipp Baumann) that makes it easier for R users to get started with Nix and also allows to install arbitrary versions of packages easily using the Nix package manager. So you can define an environment with any version of R, plus corresponding packages, and install specific versions of specific packages if needed as well. Packages that are hosted on Github can also get easily installed if needed. Let me make this clear: using Nix, you install both R and R packages so there’s no need to use <code>install.packages()</code> anymore. Everything is managed by Nix.
</p>
<p>
Using Nix, we can define our environment and build instructions as code, and have the build process always produce exactly the same result. This definition of the environment and build instructions are written using the Nix programming language inside a simple text file, which then gets used to actually realize the build. This means that regardless of “when” or “where” you rebuild your project, <em>exactly</em> the same packages (all the way down to the system libraries and compilers and all that stuff we typically never think about) will get installed to rebuild the project.
</p>
<p>
Essentially, using the Nix package manager, you can replace Docker + any of the other tools listed above to build reproducible projects. The issue with Nix however is that the entry cost is quite high: even if you’re already familiar with Linux and package managers, Nix is really an incredible deep tool. So I would say that the entry cost is around 9 out of 10…, but to bring this entry cost down, I have written 6 blog posts to get you started:
</p>
<ul>
<li>
<a href="../posts/2023-07-13-nix_for_r_part1.html">https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/</a>
</li>
<li>
<a href="../posts/2023-07-19-nix_for_r_part2.html">https://www.brodrigues.co/blog/2023-07-19-nix_for_r_part2/</a>
</li>
<li>
<a href="../posts/2023-07-30-nix_for_r_part3.html">https://www.brodrigues.co/blog/2023-07-30-nix_for_r_part3/</a>
</li>
<li>
<a href="../posts/2023-08-12-nix_for_r_part4.html">https://www.brodrigues.co/blog/2023-08-12-nix_for_r_part4/</a>
</li>
<li>
<a href="../posts/2023-09-15-nix_for_r_part5.html">https://www.brodrigues.co/blog/2023-09-15-nix_for_r_part5/</a>
</li>
<li>
<a href="../posts/2023-09-20-nix_for_r_part6.html">https://www.brodrigues.co/blog/2023-09-20-nix_for_r_part6/</a>
</li>
</ul>
<p>
Also, by the way, it is entirely possible to build a Docker image based on Ubuntu, install the Nix package manager on it, and then use Nix inside Docker to install the right software to build a reproducible project. This approach is extremely flexible, as it uses the best of both worlds in my opinion: we can take advantage of the popularity of Docker so that we can run containers anywhere, but use Nix to truly have reproducible builds. This also solves the issue I discussed before: if you’re using Nix inside Docker, it doesn’t matter if the base image gets outdated: simply use a newer base image, and Nix will take care of always installing the right versions of the needed pieces of software for your project.
</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">
Conclusion
</h2>
<p>
So which should you learn, Docker or Nix? While Docker is certainly more popular these days, I think that Nix is very interesting and not that hard to use <strong>once</strong> you learnt the basics (which does take some time). But the entry costs for any of these tools is in the end quite high and, very annoyingly, building reproducible projects does not get enough recognition, even in science where reproducibility is supposedly one of its corner stones. However, I think that you should definitely invest time in learning the tools and best practices required for building reproducible projects, because by making sure that a project is reproducible you end up increasing its quality as well. Furthermore, you avoid stressful situations where you get asked “hey, where did that graph/result/etc come from?” and you have no idea why the script that supposedly built that output does not reproduce the same output again.
</p>
<p>
If you read all the blog posts above but still want to learn and know more about reproducibility you can get my <a href="https://leanpub.com/raps-with-r/c/blog_reader">ebook at a discount</a> or get a physical copy on <a href="https://www.amazon.com/Building-reproducible-analytical-pipelines-R/dp/B0C87H6MGF/ref=sr_1_1?keywords=building+reproducible+analytical+pipelines&amp;sr=8-1">Amazon</a> or you can <a href="https://raps-with-r.dev/">read it for free</a>. That book does not discuss Nix, but I will very certainly be writing another book focusing this time on Nix during 2024.
</p>


</section>

 ]]></description>
  <category>R</category>
  <category>proramming</category>
  <guid>https://b-rodrigues.github.io/posts/2023-10-05-repro_overview.html</guid>
  <pubDate>Thu, 05 Oct 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>ZSA Voyager review</title>
  <link>https://b-rodrigues.github.io/posts/2023-09-29-voyager.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<a href="https://www.youtube.com/watch?v=NlgmH5q9uNk"> <img src="https://b-rodrigues.github.io/assets/img/travelling_with_my_keyboard.png" title="Click for banger" width="80%" height="auto"></a>
</p>
</div>
<p>
Now for something completely different than our usual programming: today I’m sharing my thoughts on the latest ZSA mechanical keyboard, the <a href="https://www.zsa.io/voyager/buy/">Voyager</a>. First things first: this is in no way shape or form sponsored by ZSA. But Erez, if you’d like to send me money you’re more than welcome.
</p>
<p>
Here’s what the keyboard looks like:
</p>
<div style="text-align:center;">
<video width="854" height="480" controls="" autoplay="" muted="" loop="">
<source src="../assets/img/voyager.mp4" type="video/mp4">
Your browser does not support the video tag. </video>
</div>
<p>
Yes, it comes with RGB LEDs. Why do mechanical keyboards come with RGB LEDs? No idea, I usually don’t care for them, but unlike other keyboards from ZSA, you cannot order the Voyager without them. So now my keyboard looks like a Christmas tree. And by the way, yes, you can get the good old regular QWERTY layout instead of the dots. I chose to get blank keys because I don’t look at my keyboard when typing.
</p>
<p>
It’s quite small and there aren’t many keys on it. But it’s very comfortable to use. I’ll try to explain why.
</p>
<p>
If you don’t know anything about mechanical keyboards, I think you might find this blog post useful. I’ll explain the basics and also why you might want to consider one if you’re a programmer.
</p>
<p>
First of all, let me just get this out of the way: typing on a mechanical keyboard will not make you type any faster. I think that people that buy mechanical keyboards also tend to be people that spend some time learning how to touch-type, so yeah, they’ll type faster than most people that never bother to learn to touch-type, but two touch-typists, one that use a mechanical keyboard and another that uses a normal keyboard, will roughly type at the same speed.
</p>
<p>
So if not for speed, why bother with mechanical keyboards?
</p>
<p>
In my opinion, the main advantage of mechanical keyboards is customization. You can customize absolutely everything: not just how the keyboard looks, but also how it works. Many mechanical keyboards come with a firmware called QMK which enables you to program each key. So for instance I have a key that types “&lt;-” and another that types “%&gt;%”, very useful for an R programmer like myself. You can configure such things at the level of you favourite text editor, but it’s nice to also have the option at the level of the hardware, because it means that you can now easily type these programming symbols anywhere: on social media, an email, a forum… Configuring this firmware on keyboards made by ZSA, like the Voyager, is incredibly easy: there’s a web-application called Oryx that you can use for all they keyboards. Simply select the keys, change what you must and flash the new firmware to your keyboard! For example here, I’m configuring a key to output “,” when pressed, but to output “_” when double-tapped:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/oryx.png" width="80%" height="auto">
</p>
</div>
<p>
And for the flashing process you don’t even have to install anything on your computer: if you’re using a Chromium based browser like Google Chrome, you can flash it from the Web Browser. You can even browse other people’s configurations, for example here’s <a href="https://configure.zsa.io/voyager/layouts/l9eWG/ErJeQ/0">mine</a> (and you can even customize the RGB).
</p>
<p>
I use the French ergonomic BÉPO layout, the English equivalent would be Dvorak. You can add different layers, for example by holding one key, all the other keys now output something different when pressed (like holding down the SHIFT key produces capital letters), but you can make any key switch layers and then any other key output anything. For example I have a layer in which I configured keys to move my mouse and click. I don’t use that very often, but in case I forget my mouse if I’m traveling, I could also use my keyboard as a mouse now.
</p>
<p>
Hardware can also be customized: the color of the keyboard, but also the keycaps (I have the blank ones, as you’ve seen above) and also the switches. If you’re not into mechanical keyboard I guess this doesn’t mean anything. Keycaps are these:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/caps.jpg" width="80%" height="auto">
</p>
</div>
<p>
and switches are these:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/switches.jpg" width="80%" height="auto">
</p>
</div>
<p>
And you can change either the caps, the switches or both. The keyboard is <em>hot-swapable</em> meaning that you can actually replace the switches. Here is a switch with a keycap on it that I removed from my keyboard:
</p>
<div style="text-align:center;">
<video width="854" height="480" controls="" loop="">
<source src="../assets/img/pressing_switch.mp4" type="video/mp4">
Your browser does not support the video tag. </video>
</div>
<p>
Again, if you’re not into mechanical keyboard it’s difficult to see why this is really a nice thing: but being able to change caps and switches allows you to truly make the keyboard feel and sound just right for you.
</p>
<p>
Let me explain: there’s switches that make no sound and that are very easy to press: they’re called linear switches. Then there’s switches that make a nice clicky sound and that require more force to press, and there’s switches that make even more noise and that require a lot of force to press. The harder ones are so-called “clicky” switches and the intermediate ones “tactile”. There’s a lot more subtlety than that, but even I don’t know everything about switches. What matters is that you can swap these, and find the ones that are just right for you. My first mechanical keyboard, also one from ZSA, the Ergodox EZ (pictured below) came with red switches. At the time, I had no idea what switches I should get, so I bought the reds because they were silent, and I figured that I would prefer silent ones. Turns out that I absolutely hated them. It didn’t fill right because they were extremely light, and simply by resting my hands on the keyboard I would press keys by mistake. Then I bought clicky switches, and since then haven’t looked back. Clicky switches make a nice “click” sound when you press them, because there’s actually a little mechanism that produces this noise when you press them. It’s like pushing an actual button. Much more satisfying, and much better, in my opinion, for typing. So for this board I got the white ones, which are the clickiest. It’s also the one’s I had for my other mechanical keyboard, the Planck EZ, also by ZSA:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/planck.jpg" width="80%" height="auto">
</p>
</div>
<p>
I also experimented with heavier ones on my other board (an Idobao ID75, a somewhat overgrown Planck, not by ZSA but also very customizable through <a href="https://get.vial.today/">VIAL</a>):
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/idobao.jpg" width="80%" height="auto">
</p>
</div>
<p>
The switches there are heavier, and I enjoy them a lot as well.
</p>
<p>
Now, this keyboard isn’t cheap, but it does come with a lot of nice stuff in the box. You get 3 usb cables, 4 more switches, several keycaps more, and a carrying bag.
</p>
<p>
And as you can see, it’s a so-called low profile keyboard:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/low_voyager_1.jpg" width="80%" height="auto">
</p>
</div>
<p>
You can even remove these little feet from the keyboard (they’re magnetic):
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/magnetic_feet.jpg" width="80%" height="auto">
</p>
</div>
<p>
to get it even lower:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/low_voyager_2.jpg" width="80%" height="auto">
</p>
</div>
<p>
I’ve never had such a keyboard in the past and I must say that it’s really comfortable to use. I don’t need to use any wrist rests anymore, which is kinda nice. Because it’s low-profile the switches and keycaps are different from the usual ones you get for other mechanical keyboards:
</p>
<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/mx_vs_choc.jpg" width="80%" height="auto">
</p>
</div>
<p>
Anyways, I really enjoy this form factor, not just that it’s low profile, but also that it doesn’t have a lot of keys. I like this, because my hands don’t need to move at all. If I need numbers for example, I switch layers, and now the keys that would usually be directly under my fingers will output numbers when pressed. So instead of my fingers going to the keys, they keys go to my fingers. It gets some time to get used to this, but once you know how to do that, it’s just great.
</p>
<p>
So, should you buy a Voyager? I might not advise it to you for a first mechanical keyboard. There’s much cheaper ones that you can get and see if mechanical keyboards are for you. If you can, try some out in a store, I think it’s especially important to find the right switches for your style. As I’ve written above, I started with linear reds which I hated, thankfully I tried clicky whites before abandoning my mechanical keyboard adventure. If you’re already a hardened mechanical keyboard user, and are looking for a light keyboard that you can take with you on your travels, I think that it’s hard to overlook the Voyager. There are other nice, very transportable keyboards out there, but the build quality of ZSA and the firmware customization tool they provide, Oryx, is hard to beat.
</p>


 ]]></description>
  <category>R</category>
  <category>proramming</category>
  <guid>https://b-rodrigues.github.io/posts/2023-09-29-voyager.html</guid>
  <pubDate>Fri, 29 Sep 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducible data science with Nix, part 6 – CI/CD has never been easier</title>
  <link>https://b-rodrigues.github.io/posts/2023-09-20-nix_for_r_part6.html</link>
  <description><![CDATA[ 




<div style="text-align:center;">
<p>
<img src="https://b-rodrigues.github.io/assets/img/gymnastics.png" width="50%">
</p>
</div>
<p>
<em>Warning: I highly recommend you read this <a href="../posts/2023-07-19-nix_for_r_part2.html">blog post</a> first, which will explain how to run a pipeline inside Nix in detail. This blog post will assume that you’ve read that one, and it would also help if you’re familiar with Github Actions, if not, read this <a href="../posts/2022-11-19-raps.html">other blog post of mine as well</a></em>
</p>
<p>
This is getting ridiculous. The meme that I’m using as a header for this blog post perfectly summaries how I feel.
</p>
<p>
This will be a short blog post, because Nix makes things so easy that there’s not much to say. I wanted to try how I could use Nix on Github Actions to run a reproducible pipeline. This pipeline downloads some data, prepares it, and fits a machine learning model. It is code that I had laying around from an old video on the now deprecated <code>{drake}</code> package, <code>{targets}</code> predecessor.
</p>
<p>
You can find the pipeline <a href="https://github.com/b-rodrigues/nix_ml_cicd_demo/tree/main">here</a> and you can also take a look at the same pipeline but which uses Docker <a href="https://github.com/b-rodrigues/mlops_demo">here</a> for comparison purposes.
</p>
<p>
What I wanted to achieve was the following: I wanted to set up a reproducible environment with Nix on my computer, work on my pipeline locally, and then have it run on Github Actions as well. But I wanted my pipeline to run exactly on the same environment as the one I was using to develop it. In a world without Nix, this means using a mix of <code>{renv}</code> (or <code>{groundhog}</code> or <code>{rang}</code>) and a Docker image that ships the right version of R. I would then need to write a Github Actions workflow file that builds that Docker image, then runs it and saves the outputs as artifacts. Also, in practice that image would not be exactly the same as my local environment: I would have the same version of R and R packages, but every other system-level dependency would be a different version unless I use that Dockerized environment to develop locally, something I suggested you should do merely <a href="../posts/2023-05-08-dock_dev_env.html">4 months ago</a> (oooh, how blind was I!).
</p>
<p>
With Nix, not only can I take care of the version of R and R packages with one single tool but also every underlying system-level dependency gets handled by Nix. So if I use a package that requires, say, Java, or GDAL, or any other of these usual suspects that make installing their R bindings so tricky, Nix will handle this for me without any intervention on my part. I can also use this environment to develop locally, and then, once I’m done working locally, <em>exactly</em> this environment, <em>exactly</em> every bit of that environment, will get rebuilt and used to run my code on Github Actions.
</p>
<p>
So <a href="https://github.com/b-rodrigues/nix_ml_cicd_demo">this is the repository</a> where you can find the code. There’s a <code>{targets}</code> script that defines the pipeline and a <code>functions/</code> folder with some code that I wrote for said pipeline. What’s unfamiliar to you (unless you’ve been reading my Nix adventures since the beginning) is the <code>default.nix</code> file:
</p>
<pre><code>let
 pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz") {};
 rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) tidymodels vetiver targets xgboost;
};
 system_packages = builtins.attrValues {
  inherit (pkgs) R;
};
in
 pkgs.mkShell {
  buildInputs = [  rpkgs system_packages  ];
 }</code></pre>
<p>
This few lines of code define an environment that pulls packages from revision <code>976fa3369d722e76f37c77493d99829540d43845</code> of <code>nixpkgs</code>. It installs the packages <code>{tidymodels}</code>, <code>{vetiver}</code>, <code>{targets}</code> and <code>{xgboost}</code> (actually, I’m not using <code>{vetiver}</code> for this <em>yet</em>, so it could even be removed). Then it also installs R. Because we’re using that specific revision of Nix, exactly the same packages (and their dependencies) will get installed, regardless of when we build this environment. I want to insist that this file is 12 lines long and it defines a complete environment. The equivalent <code>Dockerfile</code> is much longer, and not even completely reproducible, and I would have needed external tools like <code>{renv}</code> (or use the Posit CRAN mirror dated snapshots) as you can check out <a href="https://github.com/b-rodrigues/mlops_demo">here</a>.
</p>
<p>
Let’s now turn our attention to the workflow file:
</p>
<pre><code>name: train_model

on:
  push:
    branches: [main]

jobs:
  targets:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
    steps:

      - uses: actions/checkout@v3

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          logger: pretty
          log-directives: nix_installer=trace
          backtrace: full

      - name: Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Build development environment
        run: |
          nix-build

      - name: Check if previous runs exists
        id: runs-exist
        run: git ls-remote --exit-code --heads origin targets-runs
        continue-on-error: true

      - name: Checkout previous run
        if: steps.runs-exist.outcome == 'success'
        uses: actions/checkout@v2
        with:
          ref: targets-runs
          fetch-depth: 1
          path: .targets-runs

      - name: Restore output files from the previous run
        if: steps.runs-exist.outcome == 'success'
        run: |
          nix-shell default.nix --run "Rscript -e 'for (dest in scan(\".targets-runs/.targets-files\", what = character())) {
            source &lt;- file.path(\".targets-runs\", dest)
            if (!file.exists(dirname(dest))) dir.create(dirname(dest), recursive = TRUE)
            if (file.exists(source)) file.rename(source, dest)
          }'"

      - name: Run model
        run: |
          nix-shell default.nix --run "Rscript -e 'targets::tar_make()'"

      - name: Identify files that the targets pipeline produced
        run: git ls-files -mo --exclude=renv &gt; .targets-files

      - name: Create the runs branch if it does not already exist
        if: steps.runs-exist.outcome != 'success'
        run: git checkout --orphan targets-runs

      - name: Put the worktree in the runs branch if the latter already exists
        if: steps.runs-exist.outcome == 'success'
        run: |
          rm -r .git
          mv .targets-runs/.git .
          rm -r .targets-runs

      - name: Upload latest run
        run: |
          git config --local user.name "GitHub Actions"
          git config --local user.email "actions@github.com"
          rm -r .gitignore .github/workflows
          git add --all -- ':!renv'
          for file in $(git ls-files -mo --exclude=renv)
          do
            git add --force $file
          done
          git commit -am "Run pipeline"
          git push origin targets-runs

      - name: Prepare failure artifact
        if: failure()
        run: rm -rf .git .github .targets-files .targets-runs

      - name: Post failure artifact
        if: failure()
        uses: actions/upload-artifact@main
        with:
          name: ${{ runner.os }}-r${{ matrix.config.r }}-results
          path: .</code></pre>
<p>
The workflow file above is heavily inspired from the one you get when you run <code>targets::tar_github_actions()</code>. Running this puts the following <a href="https://github.com/ropensci/targets/blob/22103e19584ea15ae44328c07bc9d2699b004a47/inst/templates/github_actions.yaml">file</a> on the root of your <code>{targets}</code> project. This file is a Github Actions workflow file, which means that each time you push your code on Github, the pipeline will run in the cloud. However it needs you to use <code>{renv}</code> with the project so that the right packages get installed. You’ll also see a step called <code>Install Linux dependencies</code> which you will have to adapt to your project.
</p>
<p>
All of this can be skipped when using Nix. All that must be done is installing Nix itself, using the <code>nix-installer-action</code> from Determinate Systems, then using the <code>magic-nix-cache-action</code> which caches the downloaded packages so we don’t need to wait for the environment to build each time we push (unless we changed the environment of course) and that’s about it. We then build the environment on Github Actions using <code>nix-build</code> and then run the pipeline using <code>nix-shell default.nix –run “Rscript -e ‘targets::tar_make()’”</code>. All the other steps are copied almost verbatim from the linked file above and make sure that the computed targets only get recomputed if I edit anything that impacts them, and also that they get pushed into a branch called <code>targets-runs</code>. I say <em>copied almost verbatim</em> because some steps must run inside R, so we need to specify that we want to use the R that is available through the Nix environment we just built.
</p>
<p>
Now, each time we push, the following happens:
</p>
<ul>
<li>
if we didn’t change anything to <code>default.nix</code>, the environment gets retrieved from the cache. If we did change something, then environment gets rebuilt (or rather, only the parts that need to be rebuilt, the rest will still get retrieved from the cache)
</li>
<li>
if we didn’t change anything to the <code>_targets.R</code> pipeline itself, then every target will get skipped. If not, only the targets that need to get recomputed will get recomputed.
</li>
</ul>
<p>
One last thing that I didn’t mention: on line 9 you’ll see this:
</p>
<pre><code>runs-on: ubuntu-latest</code></pre>
<p>
this means that the Github Actions will run on the latest available version of Ubuntu, which is obviously not fixed. When the next LTS gets released in April 2024, this pipeline will be running on Ubuntu 24.04 instead of the current LTS, version 22.04. This is not good practice because we don’t want the underlying operating system to be changing, because this could have an impact on the reproducibility of our pipeline. But with Nix, this <strong>does not matter</strong>. Remember that we are using a specific revision of <code>nixpkgs</code> for our pipeline, so the <em>exact</em> same version of not only R and R packages gets installed, but every underlying piece of software that needs to be available will be installed as well. We could be running this in 50 years on Ubuntu LTS 74.04 and it would still install the same stuff and run the same code and produce exactly the same results.
</p>
<p>
This is really bonkers.
</p>
<p>
Nix is an incredibly powerful tool. I’ve been exploring and using it for 3 months now, but if something impresses me more than how useful it is, is how terribly unknown it still is. I hope that this series of blog posts will motivate other people to learn it.
</p>



 ]]></description>
  <category>R</category>
  <category>nix</category>
  <guid>https://b-rodrigues.github.io/posts/2023-09-20-nix_for_r_part6.html</guid>
  <pubDate>Wed, 20 Sep 2023 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
