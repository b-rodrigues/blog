{
  "hash": "675659d94e6e1b6760c355495984988a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Method of Simulated Moments with R\"\ndate: \"2013-01-29\"\ncategories:\n  - R\ntoc: true\nexecute:\n  freeze: auto\n---\n\n\n\n<!-- MathJax scripts -->\n<script type=\"text/javascript\" async\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n\n</head>\n\n\n<body>\n\n<p>This document details section <em>12.5.6. Unobserved Heterogeneity Example</em>. The original source code giving the results from table 12.3 are available from the authors&#39; site <a href=\"http://cameron.econ.ucdavis.edu/mmabook/mmaprograms.html\">here</a> and written for Stata. This is an attempt to translate the code to R.</p>\n\n<p>Consult the original source code if you want to read the authors&#39; comments. If you want the R source code without all the commentaries, grab it here. This is not guaranteed to work, nor to be correct. It could set your pet on fire and/or eat your first born. Use at your own risk. I may, or may not, expand this example. Corrections, constructive criticism are welcome.</p>\n\n<p>The model is the same as the one described here, so I won&#39;t go into details. The moment condition used is $E[(y_i-\\theta-u_i)]=0$, so we can replace the expectation operator by the empirical mean:</p>\n\n<p>$$\\dfrac{1}{N} \\sum_{i=1}^N(y_i - \\theta - E[u_i])=0$$</p>\n\n<p>Supposing that $E[\\overline{u}]$ is unknown, we can instead use the method of simulated moments for $\\theta$ defined by:</p>\n\n<p>$$\\dfrac{1}{N} \\sum_{i=1}^N(y_i - \\theta - \\dfrac{1}{S} \\sum_{s=1}^S u_i^s)=0$$</p>\n\n<h3>Import the data</h3>\n\n<p>You can consult the original source code to see how the authors simulated the data. To get the same results, and verify that I didn&#39;t make mistakes I prefer importing their data directly from their website.</p>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read.table(\"http://cameron.econ.ucdavis.edu/mmabook/mma12p2mslmsm.asc\")\nu <- data[, 1]\ne <- data[, 2]\ny <- data[, 3]\nnumobs <- length(u)\nsimreps <- 10000\n```\n:::\n\n\n\n<h3>Simulation</h3>\n\n<p>In the code below, we simulate the equation defined above:</p>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusim <- -log(-log(runif(simreps)))\nesim <- rnorm(simreps, 0, 1)\n\nisim <- 0\nwhile (isim < simreps) {\n\n    usim = usim - log(-log(runif(simreps)))\n    esim = esim + rnorm(simreps, 0, 1)\n\n    isim = isim + 1\n\n}\n\nusimbar = usim/simreps\nesimbar = esim/simreps\n\ntheta = y - usimbar - esimbar\n\ntheta_msm <- mean(theta)\napprox_sterror <- sd(theta)/sqrt(simreps)\n```\n:::\n\n\n\n<p>These steps yield the following results:</p>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta_msm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.187978\n```\n\n\n:::\n:::\n\n\n\nand\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napprox_sterror\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.01676286\n```\n\n\n:::\n:::\n\n\n\n</body>\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}