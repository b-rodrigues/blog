{
  "hash": "527bbcc620f99f5a95ef8b1352e2f356",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2017-11-13\ntitle: \"Peace of mind with purrr\"\ncategories:\n  - R\n  - programming\ntoc: true\n---\n\n\n\nI think what I enjoy the most about functional programming is the peace of mind that comes with it.\nWith functional programming, there's a lot of stuff you don't need to think about. You can write\nfunctions that are general enough so that they solve a variety of problems. For example, imagine\nfor a second that R does not have the `sum()` function anymore. If you want to compute the sum of,\nsay, the first 100 integers, you could write a loop that would do that for you:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers = 0\n\nfor (i in 1:100){\n  numbers = numbers + i\n}\n\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5050\n```\n\n\n:::\n:::\n\n\n\nThe problem with this approach, is that you cannot reuse any of the code there, even if you put it\ninside a function. For instance, what if you want to merge 4 datasets together? You would need\nsomething like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\ndata(mtcars)\n\nmtcars1 = mtcars %>%\n  mutate(id = \"1\")\n\nmtcars2 = mtcars %>%\n  mutate(id = \"2\")\n\nmtcars3 = mtcars %>%\n  mutate(id = \"3\")\n\nmtcars4 = mtcars %>%\n  mutate(id = \"4\")\n\ndatasets = list(mtcars1, mtcars2, mtcars3, mtcars4)\n\ntemp = datasets[[1]]\n\nfor(i in 1:3){\n  temp = full_join(temp, datasets[[i+1]])\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 128\nColumns: 12\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…\n$ id   <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", …\n```\n\n\n:::\n:::\n\n\n\nOf course, the logic is very similar as before, but you need to think carefully about the structure\nholding your elements (which can be numbers, datasets, characters, etc...) as well as be careful\nabout indexing correctly... and depending on the type of objects you are working on, you might need\nto tweak the code further.\n\nHow would a functional programming approach make this easier? Of course, you could use\n`purrr::reduce()` to solve these problems. However, since I assumed that `sum()` does not exist,\nI will also assume that `purrr::reduce()` does not exist either and write my own, clumsy\nimplementation. Here's the code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_reduce = function(a_list, a_func, init = NULL, ...){\n\n  if(is.null(init)){\n    init = `[[`(a_list, 1)\n    a_list = tail(a_list, -1)\n  }\n\n  car = `[[`(a_list, 1)\n  cdr = tail(a_list, -1)\n  init = a_func(init, car, ...)\n\n  if(length(cdr) != 0){\n    my_reduce(cdr, a_func, init, ...)\n  }\n  else {\n    init\n  }\n}\n```\n:::\n\n\n\nThis can look much more complicated than before, but the idea is quite simple; if you know about\nrecursive functions (recursive functions are functions that call themselves). I won't explain how\nthe function works, because it is not the main point of the article (but if\nyou're curious, I encourage you to play around with it). The point is that now, I can do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_reduce(list(1,2,3,4,5), `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_reduce(datasets, full_join) %>% glimpse\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\nJoining with `by = join_by(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear,\ncarb, id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 128\nColumns: 12\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…\n$ id   <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", …\n```\n\n\n:::\n:::\n\n\n\nBut since `my_reduce()` is very general, I can even do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_reduce(list(1, 2, 3, 4, \"5\"), paste)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 2 3 4 5\"\n```\n\n\n:::\n:::\n\n\n\nOf course, `paste()` is vectorized, so you could just as well do `paste(1, 2, 3, 4, 5)`, but again, I want\nto insist on the fact that writing functions, even if they look a bit complicated, can save you a huge\namount of time in the long run.\n\nBecause I know that my function is quite general, I can be confident that it will work in a lot\nof different situations; as long as the `a_func` argument is a binary operator that combines the\nelements inside `a_list`, it's going to work. And I\ndon't need to think about indexing, about having temporary variables or thinking about the structure\nthat will hold my results.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}