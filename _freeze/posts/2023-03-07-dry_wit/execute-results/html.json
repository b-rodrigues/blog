{
  "hash": "873d69055b25a6db8df399be4cfcda27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2023-03-07\ntitle: Software engineering techniques that non-programmers who write a lot of code can benefit from — the DRY WIT approach\ncategories:\n  - R\n  - proramming\ntoc: true\nexecute:\n  freeze: auto\n---\n\n\n\n\n\n<div style=\"text-align:center;\">\n<p><img src=\"../assets/img/archetypical_data_scientist.png\" width=\"80%\" height=\"auto\"></p>\n</div>\n<p>Data scientists, statisticians, analysts, researchers, and many other\nprofessionals write <em>a lot of code</em>.</p>\n<p>Not only do they write a lot of code, but they must also read and review a lot\nof code as well. They either work in teams and need to review each other’s code,\nor need to be able to reproduce results from past projects, be it for peer\nreview or auditing purposes. And yet, they never, or very rarely, get taught\nthe tools and techniques that would make the process of writing, collaborating,\nreviewing and reproducing projects possible.</p>\n<p>Which is truly unfortunate because software engineers face the same challenges\nand solved them decades ago. Software engineers developed a set of project\nmanagement techniques and tools that non-programmers who write a lot of code\ncould benefit from as well.</p>\n<p>These tools and techniques can be used right from the start of a project at a\nminimal cost, such that the analysis is well-tested, well-documented,\ntrustworthy and reproducible <em>by design</em>. Projects are going to be reproducible\nsimply because they were engineered, from the start, to be reproducible.</p>\n<p>But all these tools, frameworks and techniques boil down to two acronyms that I\nlike to keep in my head at all times:</p>\n<ul>\n<li>DRY: Don’t Repeat Yourself;</li>\n<li>WIT: Write IT down.</li>\n</ul>\n<p>DRY WIT: by systematically avoiding not to repeat yourself and\nby writing everything down, projects become well-tested, well-documented,\ntrustworthy and reproducible by design. Why is that?</p>\n<div id=\"dry-dont-repeat-yourself\" class=\"section level2\">\n<h2>DRY: Don’t Repeat Yourself</h2>\n<p>Let’s start with DRY: what does it mean not having to repeat oneself? It means:</p>\n<ul>\n<li>using functions instead of copy-and-pasting bits of code here and there;</li>\n<li>using literate programming, to avoid having to copy and paste graphs and tables into\nword or pdf documents;</li>\n<li>treating code as data and making use of templating.</li>\n</ul>\n<p>The most widely used programming languages for data science/statistics, Python and R,\nboth have first-class functions. This means that functions can be manipulated like\nany other object. So something like:</p>\n<pre class=\"r\"><code>Reduce(`+`, seq(1:100))</code></pre>\n<pre><code>## [1] 5050</code></pre>\n<p>where the function <code>+</code>() gets used as an argument of the higher-order <code>Reduce()</code>\nfunction is absolutely valid (and so is Python’s equivalent <code>reduce</code> from\n<code>functools</code>) and avoids having to use a for-loop which can lead to other issues.\nGenerally speaking, the functional programming paradigm lends itself very\nnaturally to data analysis tasks, and in my opinion data scientists and\nstatisticians would benefit a lot from adopting this paradigm.</p>\n<p>Literate programming is another tool that needs to be in the toolbox of\nany person analysing data. This is because at the end of the day, the results\nof an analysis need to be in some form of document. Without literate programming,\nthis is how you would draft reports:</p>\n<div style=\"text-align:center;\">\n<p><img src=\"https://github.com/b-rodrigues/rap4all/blob/master/images/report_draft_loop.png?raw=true\" width=\"100%\"></p>\n</div>\n<p>But with literate programming, this is how this loop would look like:</p>\n<div style=\"text-align:center;\">\n<p><img src=\"https://github.com/b-rodrigues/rap4all/blob/master/images/md_draft_loop.png?raw=true\" width=\"100%\"></p>\n</div>\n<p><a href=\"https://quarto.org/\">Quarto</a> is the latest open-source scientific and technical\npublishing system that leverages Pandoc and supports R, Python, Julia and\nObservableJs right out of the box.</p>\n<p>Below is a little Quarto Hello World:</p>\n<pre class=\"default\"><code>---\noutput: pdf\n\n---\n\nIn this example we embed parts of the examples from the\n\\texttt{kruskal.test} help page into a LaTeX document:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata (airquality)\nkruskal.test(Ozone ~ Month, data = airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tKruskal-Wallis rank sum test\n\ndata:  Ozone by Month\nKruskal-Wallis chi-squared = 29.267, df = 4, p-value = 6.901e-06\n```\n\n\n:::\n:::\n\n\n\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-03-07-dry_wit_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n</code></pre>\n<p>Compiling this document results in the following:</p>\n<div style=\"text-align:center;\">\n<img src=\"https://raw.githubusercontent.com/b-rodrigues/rap4all/master/images/hello_rmd.PNG\" width=\"100%\">\n<figcaption>\nExample from Leisch’s 2002 paper.\n</figcaption>\n</div>\n<p>Of course, you could use Python code chunks instead of R, you could also compile\nthis document to Word, or HTML, or anything else really. By combining code and\nprose, the process of data analysis gets streamlined and we don’t need to repeat\nourselves copy and pasting images and tables into Word documents.</p>\n<p>Finally, treating code as data is also quite useful. This means that it is\npossible to compute on the language itself. This is a more advanced topic, but\ndefinitely worth the effort. As an illustration, consider the following R toy example:</p>\n<pre class=\"r\"><code>show_and_eval &lt;- function(f, ...){\n  f &lt;- deparse(substitute(f))\n  dots &lt;- list(...)\n  message(&quot;Evaluating: &quot;, f, &quot;() with arguments: &quot;, deparse(dots))\n  do.call(f, dots)\n}</code></pre>\n<p>Running this function does the following:</p>\n<pre class=\"r\"><code>show_and_eval(sqrt, 2)</code></pre>\n<pre><code>## Evaluating: sqrt() with arguments: list(2)</code></pre>\n<pre><code>## [1] 1.414214</code></pre>\n<pre class=\"r\"><code>show_and_eval(mean, x = c(NA, 1, 2))</code></pre>\n<pre><code>## Evaluating: mean() with arguments: list(x = c(NA, 1, 2))</code></pre>\n<pre><code>## [1] NA</code></pre>\n<pre class=\"r\"><code>show_and_eval(mean, x = c(NA, 1, 2), na.rm = TRUE)</code></pre>\n<pre><code>## Evaluating: mean() with arguments: list(x = c(NA, 1, 2), na.rm = TRUE)</code></pre>\n<pre><code>## [1] 1.5</code></pre>\n<p>This is incredibly useful when writing packages (to know more about these\ntechniques in the R programming language, read the chapter <em>Metaprogramming</em> from\n<a href=\"https://adv-r.hadley.nz/metaprogramming.html\">Advanced R</a>).</p>\n</div>\n<div id=\"wit-write-it-down\" class=\"section level2\">\n<h2>WIT: Write IT down</h2>\n<p>Now on the WIT bit: <em>write it down</em>. You’ve just written a function. To see if\nit works correctly, you test it in the interactive console. You execute the\ntest, see that it works, and move on. But wait! What you just did is called a\nunit test. Instead of writing that in the console and then never use it ever\nagain, write it down in a script. Now you’ve got a unit test for that function\nthat you can execute each time you update that function’s code, and make sure\nthat it keeps working as expected. There are many unit testing frameworks that\ncan help you how to write unit tests consistently and run them automatically.</p>\n<p>Documentation: write it down! How does the function work? What are its inputs?\nIts outputs? What else should the user know to make it work? Very often,\ndocumentation is but a series of comments in your scripts. That’s already nice,\nbut using literate programming, you could also turn these comments into proper\ndocumentation. You could use <em>docstrings</em> in Python or <code>{roxygen2}</code> style\ncomments in R.</p>\n<p>Another classic: you correct some data manually in the raw dataset (very often a\n<code>.csv</code> or <code>.xlsx</code> file). For example, when dealing with data on people, sex is\nsometimes “M” or “F”, sometimes “Male” or “Female”, sometimes “1” or “0”. You\nspot a couple of inconsistencies and decide to <em>quickly</em> correct them by hand.\nMaybe only 3 men were coded as “Male” so you simply erase the “ale” and go on\nwith your project. Stop!</p>\n<p>Write IT down!</p>\n<p>Write a couple of lines of code that does the replacement for you. Not only will\nthis leave a trace, it will ensure that when you get an update to that data in\nthe future you don’t have to remember to have to change it by hand.</p>\n<p>You should aim at completely eliminating any required manual intervention when\nbuilding your project. A project that can be fully run by a machine is easier to\ndebug, its execution can be scheduled and can be iterated over very quickly.</p>\n<p>Something else that you should write down, or rather, let another tool do it for\nyou: how you collaborate with your teammates. For this, you should be using\nGit. Who changed what part of what function when? If the project’s code is\nversioned, Git writes it down for you. You want to experiment with a new\nfeature? Write it down by creating a new branch and going nuts. There’s something\nwrong in the code? Write it down as an issue on your versioning platform (usually\nGithub).</p>\n<p>There are many more topics that us disciplines of the data could learn from\nsoftware engineers. I’m currently working on a free ebook that you can read\n<a href=\"https://raps-with-r.dev/\">here</a> that teaches these techniques. If this post\nopened your appetite, give the book a go!</p>\n",
    "supporting": [
      "2023-03-07-dry_wit_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}