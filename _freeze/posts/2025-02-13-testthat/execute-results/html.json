{
  "hash": "a00e00c4a649f9c88cc08179663ab232",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2025-02-13\ntitle: Using options() to inject a function's internal variable for reproducible testing\ncategories:\n  - R\n  - data-science\ntoc: true\nexecute:\n  freeze: auto\n---\n\n\n\n*No image this time*\n\nImagine you have a function that does something complicated, and in the middle\nof its definition it generates a variable. Now suppose that you want to save\nthis variable and then re-use it for tests, what I mean is that you want your\nfunction to always reproduce this intermediary variable, regardless of what you\ngive it as inputs. This can be useful for testing, if computing this\nintermediate variable is costly.\n\nIn my `{rix}` package, the `rix()` function generates valid Nix expressions\nfrom R input and these Nix expressions can then be used to build reproducible\ndevelopment environments that include R, R packages, development libraries, and so on.\nIf you want a 5-minute intro to `{rix}`, click\n[here](https://www.youtube.com/watch?v=OOu6gjQ310c).\n\nAnyways, sometimes, computing these expressions can take some time, especially\nif the users wants to include remote dependencies that have themselves remote\ndependencies. `rix()` will try to look for suitable GitHub commits to pin all\nthe packages for reproducibility purposes, and this can imply quite a lot of api\ncalls. Now for my tests, I wanted to use an already generated `default.nix` file\n(which contains the generated Nix expression) but I didn't want to have to\nrecompute it every time I ran the test and I couldn't simply use it as is for\nthe test either. You see, that `default.nix` was in an intermediary state,\nbefore `rix()` is supposed to do some post-processing to it, which is what I\nactually want to test (I want to actually test the argument that makes `rix()`\nskip this post-processing step).\n\nSo suppose `rix()` looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nrix <- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n  default.nix_file <- ... # it's generated here\n  # Then a bunch of things happen to it\n  out <- f(default.nix_file)\n  writeLines(out, path) # this is what's written\n}\n```\n:::\n\n\n\nNow what I want is to be able to \"overwrite\" the `default.nix_file` variable on\nline 4 when testing, to provide want I want. This way, I can call `rix()` with\nsome \"easy\" parameters that make the computations up to that point very quick.\nMy goal is essentially to test `f()` (line 6), which begs the question, why not\nwrite `f()` as a separate function and test it? This would be the best practice,\nhowever, I don't really have such an `f()`, rather it's a series of complicated\nsteps that follow and rewriting everything to make it easily testable would just\ntake too much time.\n\nInstead, I opted for the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nrix <- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n\n  stub_default.nix <- getOption(\"TESTTHAT_DEFAULT.NIX\", default = NULL)\n\n  if(!is.null(stub_default.nix)){\n    default.nix_file <- readLines(stub_default.nix)\n  } else {\n    default.nix_file <- ... # it's generated here if not being tested\n  }\n  out <- f(default.nix_file)\n  # Then a bunch of things happen to it\n  writeLines(out, path) # this is what's written\n}\n```\n:::\n\n\n\nOn line 5, I get the option `\"TESTTHAT_DEFAULT.NIX\"` and if it doesn't exist,\n`stub_default.nix` will be set to `NULL`. So if it's `NULL` it's business as\nusual, if not, then that `default.nix` file dedicated for testing gets passed\nfurther down. In a sense, I injected the variable I needed in the spot I needed.\n\nThen, my tests looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\ntestthat::test_that(\"remove_duplicate_entries(), don't remove duplicates if skip\", {\n\n\n  dups_entries_default.nix <- paste0(\n    testthat::test_path(),\n    \"/testdata/default-nix_samples/dups-entries_default.nix\")\n\n  tmpdir <- tempdir()\n\n  # This copies the file I need in the right path\n  destination_file <- file.path(tempdir(), basename(dups_entries_default.nix))\n  file.copy(dups_entries_default.nix, destination_file, overwrite = TRUE)\n\n  on.exit(\n    unlink(tmpdir, recursive = TRUE, force = TRUE),\n    add = TRUE\n  )\n\n  removed_dups <- function(destination_file) {\n\n    # Set the option to the file path and clean the option afterwards\n    op <- options(\"TESTTHAT_DEFAULT.NIX\" = destination_file)\n    on.exit(options(op), add = TRUE, after = FALSE)\n\n    out <- rix(\n      date = \"2025-02-10\",\n      project_path = tmpdir,\n      overwrite = TRUE,\n      skip_post_processing = TRUE) # <- this is actually want I wanted to test\n    file.path(destination_file)\n  }\n\n\n  testthat::expect_snapshot_file(\n    path = removed_dups(destination_file),\n    name = \"skip-dups-entries_default.nix\",\n  )\n})\n```\n:::\n\n\n\nOn line 22, I set the option and on line 23 I write code to remove that option\nonce the test is done, to not mess up subsequent tests. This is a snapshot test,\nso now I can take a look at the resulting file, and indeed make sure that\npost-processing was skipped, as expected.\n\nHow would you have done this?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}